<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>threeML.plugins.SpectrumLike &mdash; The Multi-Mission Maximum Likelihood framework  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/dark_mode_css/general.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/dark_mode_css/dark.css" />

  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
        <script src="../../../_static/dark_mode_js/default_dark.js"></script>
        <script src="../../../_static/dark_mode_js/theme_switcher.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            The Multi-Mission Maximum Likelihood framework
              <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../team.html">Project &amp; Team</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../intro.html">Intro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/logging.html">Logging and Verbosity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../xspec_users.html">Notes for XSPEC Users</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/Minimization_tutorial.html">Minimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/Bayesian_tutorial.html">Bayesian Posterior Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/sampler_docs.html">Bayesian Sampler Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../plugins.html">Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modeling.html">Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/API.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/API.html#threeml">threeML</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes.html">Release Notes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Features and examples:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/Analysis_results_showcase.html">Analysis Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/random_variates.html">Random Variates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/Point_source_plotting.html">Point source plotting basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/Building_Plugins_from_TimeSeries.html">Constructing plugins from TimeSeries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/grb080916C.html">Analyzing GRB 080916C</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/APEC_doc.html">Fitting XMM-Newton data with the APEC model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/joint_BAT_gbm_demo.html">Example joint fit between GBM and Swift BAT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/joint_fitting_xrt_and_gbm_xspec_models.html">Joint fitting XRT and GBM data with XSPEC models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/flux_examples.html">Point Source Fluxes and Multiple Sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/Fermipy_LAT.html">Fermi-LAT via FermiPyLike</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/LAT_Transient_Builder_Example.html">Analysis of GRB 190114C with Fermi-LAT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/Time-energy-fit.html">Time-energy fit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/synthetic_spectra.html">Generating Synthetic Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/gof_lrt.html">Goodness of Fit and Model Comparison</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">The Multi-Mission Maximum Likelihood framework</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../threeML.html">threeML</a></li>
      <li class="breadcrumb-item active">threeML.plugins.SpectrumLike</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for threeML.plugins.SpectrumLike</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numba</span> <span class="k">as</span> <span class="nn">nb</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">astromodels</span> <span class="kn">import</span> <span class="n">Model</span><span class="p">,</span> <span class="n">PointSource</span><span class="p">,</span> <span class="n">clone_model</span>
<span class="kn">from</span> <span class="nn">astromodels.core.parameter</span> <span class="kn">import</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">astromodels.functions.priors</span> <span class="kn">import</span> <span class="n">Truncated_gaussian</span><span class="p">,</span> <span class="n">Uniform_prior</span>
<span class="kn">from</span> <span class="nn">past.utils</span> <span class="kn">import</span> <span class="n">old_div</span>
<span class="kn">from</span> <span class="nn">threeML.config.config</span> <span class="kn">import</span> <span class="n">threeML_config</span>
<span class="kn">from</span> <span class="nn">threeML.config.plotting_structure</span> <span class="kn">import</span> <span class="n">BinnedSpectrumPlot</span>
<span class="kn">from</span> <span class="nn">threeML.exceptions.custom_exceptions</span> <span class="kn">import</span> <span class="n">NegativeBackground</span>
<span class="kn">from</span> <span class="nn">threeML.io.logging</span> <span class="kn">import</span> <span class="n">setup_logger</span>
<span class="kn">from</span> <span class="nn">threeML.io.package_data</span> <span class="kn">import</span> <span class="n">get_path_of_data_file</span>
<span class="kn">from</span> <span class="nn">threeML.io.plotting.data_residual_plot</span> <span class="kn">import</span> <span class="n">ResidualPlot</span>
<span class="kn">from</span> <span class="nn">threeML.io.plotting.light_curve_plots</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">channel_plot</span><span class="p">,</span>
    <span class="n">disjoint_patch_plot</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">threeML.io.rich_display</span> <span class="kn">import</span> <span class="n">display</span>
<span class="kn">from</span> <span class="nn">threeML.plugin_prototype</span> <span class="kn">import</span> <span class="n">PluginPrototype</span>
<span class="kn">from</span> <span class="nn">threeML.plugins.XYLike</span> <span class="kn">import</span> <span class="n">XYLike</span>
<span class="kn">from</span> <span class="nn">threeML.utils.binner</span> <span class="kn">import</span> <span class="n">Rebinner</span>
<span class="kn">from</span> <span class="nn">threeML.utils.spectrum.binned_spectrum</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">BinnedSpectrum</span><span class="p">,</span>
    <span class="n">ChannelSet</span><span class="p">,</span>
    <span class="n">Quality</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">threeML.utils.spectrum.pha_spectrum</span> <span class="kn">import</span> <span class="n">PHASpectrum</span>
<span class="kn">from</span> <span class="nn">threeML.utils.spectrum.spectrum_likelihood</span> <span class="kn">import</span> <span class="n">statistic_lookup</span>
<span class="kn">from</span> <span class="nn">threeML.utils.statistics.stats_tools</span> <span class="kn">import</span> <span class="n">Significance</span>
<span class="kn">from</span> <span class="nn">threeML.utils.string_utils</span> <span class="kn">import</span> <span class="n">dash_separated_string_to_tuple</span>

<span class="k">if</span> <span class="n">threeML_config</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">use_threeml_style</span><span class="p">:</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">get_path_of_data_file</span><span class="p">(</span><span class="s2">&quot;threeml.mplstyle&quot;</span><span class="p">)))</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">setup_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">NO_REBIN</span> <span class="o">=</span> <span class="mf">1e-99</span>

<span class="n">__instrument_name</span> <span class="o">=</span> <span class="s2">&quot;General binned spectral data&quot;</span>

<span class="c1"># This defines the known noise models for source and/or background spectra</span>
<span class="n">_known_noise_models</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">,</span> <span class="s2">&quot;ideal&quot;</span><span class="p">,</span> <span class="s2">&quot;modeled&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="SpectrumLike"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike">[docs]</a><span class="k">class</span> <span class="nc">SpectrumLike</span><span class="p">(</span><span class="n">PluginPrototype</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">observation</span><span class="p">:</span> <span class="n">BinnedSpectrum</span><span class="p">,</span>
        <span class="n">background</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span><span class="n">BinnedSpectrum</span><span class="p">,</span> <span class="n">XYLike</span><span class="p">,</span> <span class="s2">&quot;SpectrumLike&quot;</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">background_exposure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tstart</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tstop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A plugin for generic spectral data, accepts an observed binned spectrum,</span>
<span class="sd">        and a background binned spectrum or plugin with the background data.</span>

<span class="sd">        In the case of a binned background spectrum, the background model is profiled</span>
<span class="sd">        out and the appropriate profile-likelihood is used to fit the total spectrum. In this</span>
<span class="sd">        case, caution must be used when there are zero background counts in bins as the</span>
<span class="sd">        profiled background parameters (one per channel) will then have zero information from which to</span>
<span class="sd">        constrain the background. It is recommended to bin the spectrum such that there is one background count</span>
<span class="sd">        per channel.</span>

<span class="sd">        If either an SpectrumLike or XYLike instance is provided as background, it is assumed that this is the</span>
<span class="sd">        background data and the likelihood model from this plugin is used to simultaneously fit the background</span>
<span class="sd">        and source.</span>

<span class="sd">        :param name: the plugin name</span>
<span class="sd">        :param observation: the observed spectrum</span>
<span class="sd">        :param background: the background spectrum or a plugin from which the background will be modeled</span>
<span class="sd">        :param background_exposure: (optional) adjust the background exposure of the modeled background data comes from and</span>
<span class="sd">        XYLike plugin</span>
<span class="sd">        :param verbose: turn on/off verbose logging</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Just a toggle for verbosity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">observation</span><span class="p">,</span> <span class="n">BinnedSpectrum</span><span class="p">):</span>

            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;The observed spectrum is not an instance of BinnedSpectrum&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Precomputed observed (for speed)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="p">:</span> <span class="n">BinnedSpectrum</span> <span class="o">=</span> <span class="n">observation</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_has_contiguous_energies</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">observation</span><span class="o">.</span><span class="n">is_contiguous</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_predefined_energies</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">observation</span><span class="o">.</span><span class="n">edges</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_observed_counts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">counts</span>

        <span class="c1"># initialize the background</span>

        <span class="n">background_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_setup</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">observation</span><span class="p">)</span>

        <span class="c1"># unpack the parameters</span>

        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_background_counts</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_background_counts</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">background_parameters</span>

        <span class="c1"># Init everything else to None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_like_model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Model</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Rebinner</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stokes</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># probe the noise models and then setup the appropriate count errors</span>

        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_observation_noise_model</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_probe_noise_models</span><span class="p">()</span>

        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_observed_count_errors</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_back_count_errors</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count_errors_initialization</span><span class="p">()</span>

        <span class="c1"># Init the integral methods for background and model integration to default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model_integrate_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;simpson&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_background_integrate_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;simpson&quot;</span>

        <span class="c1"># Initialize a mask that selects all the data.</span>
        <span class="c1"># We will initially use the quality mask for the PHA file</span>
        <span class="c1"># and set any quality greater than 0 to False. We want to save</span>
        <span class="c1"># the native quality so that we can warn the user if they decide to</span>
        <span class="c1"># select channels that were flagged as bad.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">n_channels</span><span class="p">),</span> <span class="nb">bool</span>
        <span class="p">)</span>

        <span class="c1"># Now create the nuisance parameter for the effective area correction, which is fixed</span>
        <span class="c1"># by default. This factor multiplies the model so that it can account for calibration uncertainties on the</span>
        <span class="c1"># global effective area. By default it is limited to stay within 20%</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nuisance_parameter</span><span class="p">:</span> <span class="n">Parameter</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span>
            <span class="s2">&quot;cons_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">,</span>
            <span class="mf">1.0</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span>
            <span class="n">delta</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
            <span class="n">free</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Effective area correction for </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">nuisance_parameters</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">nuisance_parameters</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nuisance_parameter</span><span class="o">.</span><span class="n">name</span>
        <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nuisance_parameter</span>

        <span class="c1"># if we have a background model we are going</span>
        <span class="c1"># to link all those parameters to new nuisance parameters</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> is using a modeled background&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">=</span> <span class="s2">&quot;modeled&quot;</span>

            <span class="k">for</span> <span class="n">par_name</span><span class="p">,</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span><span class="o">.</span><span class="n">likelihood_model</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">):</span>

                <span class="c1"># create a new parameters that is like the one from the background model</span>

                <span class="n">local_name</span> <span class="o">=</span> <span class="s2">&quot;bkg_</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">par_name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="n">local_name</span> <span class="o">=</span> <span class="n">local_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>

                <span class="n">nuisance_parameters</span><span class="p">[</span><span class="n">local_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameter</span>

                <span class="k">if</span> <span class="n">parameter</span><span class="o">.</span><span class="n">prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                    <span class="n">nuisance_parameters</span><span class="p">[</span><span class="n">local_name</span><span class="p">]</span><span class="o">.</span><span class="n">prior</span> <span class="o">=</span> <span class="n">parameter</span><span class="o">.</span><span class="n">prior</span>

                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">par_name</span><span class="si">}</span><span class="s2"> has passed its prior&quot;</span><span class="p">)</span>

                <span class="c1"># now get the background likelihood model</span>

                <span class="n">differential_flux</span><span class="p">,</span> <span class="n">integral</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_diff_flux_and_integral</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span><span class="o">.</span><span class="n">likelihood_model</span><span class="p">,</span>
                    <span class="n">integrate_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_integrate_method</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_background_integral_flux</span> <span class="o">=</span> <span class="n">integral</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">SpectrumLike</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nuisance_parameters</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span><span class="p">,</span> <span class="n">XYLike</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">background_exposure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;An XYLike plugin is modeling the background but background_exposure is not set. &quot;</span>
                    <span class="s2">&quot;It is assumed the observation and background have the same exposure&quot;</span>
                <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_explict_background_exposure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_explicit_background_exposure</span> <span class="o">=</span> <span class="n">background_exposure</span>

        <span class="c1"># The following vectors are the ones that will be really used for the computation. At the beginning they just</span>
        <span class="c1"># point to the original ones, but if a rebinner is used and/or a mask is created through set_active_measurements,</span>
        <span class="c1"># they will contain the rebinned and/or masked versions</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_current_observed_counts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_counts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_observed_count_errors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span>
        <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_count_errors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_background_counts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span>
        <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_counts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_scaled_background_counts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span>
        <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_background_counts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_back_count_errors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span>
        <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_back_count_errors</span>

        <span class="c1"># This will be used to keep track of how many syntethic datasets have been generated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_synthetic_datasets</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">tstart</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_tstart</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">tstart</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_tstart</span> <span class="o">=</span> <span class="n">observation</span><span class="o">.</span><span class="n">tstart</span>

        <span class="k">if</span> <span class="n">tstop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_tstop</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">tstop</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_tstop</span> <span class="o">=</span> <span class="n">observation</span><span class="o">.</span><span class="n">tstop</span>

        <span class="c1"># This is so far not a simulated data set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_simulation_storage</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># set the mask to the native quality</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">quality</span><span class="o">.</span><span class="n">good</span>
        <span class="c1"># Apply the mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_mask_to_original_vectors</span><span class="p">()</span>

        <span class="c1"># this will be immeadiately changed if inherited</span>

        <span class="c1"># calculate all scalings between area and exposure</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_precalculations</span><span class="p">()</span>

        <span class="c1"># now create a likelihood object for the call</span>
        <span class="c1"># we pass the current object over as well</span>
        <span class="c1"># the likelihood object is opaque to the class and</span>
        <span class="c1"># keeps a pointer of the plugin inside so that the current</span>
        <span class="c1"># counts, bkg, etc. are always up to date</span>
        <span class="c1"># This way, when evaluating the likelihood,</span>
        <span class="c1"># no checks are involved because the appropriate</span>
        <span class="c1"># noise models are pre-selected</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_evaluator</span> <span class="o">=</span> <span class="n">statistic_lookup</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">observation_noise_model</span>
        <span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">background_noise_model</span><span class="p">](</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_count_errors_initialization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        compute the  count errors for the observed and background spectra</span>


<span class="sd">        :return:  (observed_count_errors, background_count errors)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if there is not a background the dictionary</span>
        <span class="c1"># will crash, so we need to do a small check</span>

        <span class="n">tmp_bkg_count_errors</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">tmp_bkg_count_errors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">count_errors</span>

        <span class="n">count_errors_lookup</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;poisson&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;poisson&quot;</span><span class="p">:</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmp_bkg_count_errors</span><span class="p">),</span>
                <span class="kc">None</span><span class="p">:</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">},</span>
            <span class="c1"># gaussian source</span>
            <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">count_errors</span><span class="p">,</span>
                    <span class="n">tmp_bkg_count_errors</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="kc">None</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">count_errors</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">},</span>
        <span class="p">}</span>

        <span class="k">try</span><span class="p">:</span>

            <span class="n">error_tuple</span> <span class="o">=</span> <span class="n">count_errors_lookup</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_observation_noise_model</span><span class="p">][</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span>
            <span class="p">]</span>  <span class="c1"># type: tuple</span>

        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">):</span>

            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The noise combination of source: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_observation_noise_model</span><span class="si">}</span><span class="s2">, background: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span><span class="si">}</span><span class="s2">  is not supported&quot;</span>
            <span class="p">)</span>

            <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">errors</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">error_tuple</span><span class="p">,</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_counts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_counts</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;observed&quot;</span><span class="p">,</span> <span class="s2">&quot;background&quot;</span><span class="p">],</span>
        <span class="p">):</span>

            <span class="c1"># if the errors are not None then we want to make sure they make sense</span>
            <span class="k">if</span> <span class="n">errors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="n">zero_idx</span> <span class="o">=</span> <span class="n">errors</span> <span class="o">==</span> <span class="mi">0</span>  <span class="c1"># type: np.ndarray</span>

                <span class="c1"># check that zero error =&gt; zero counts</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">errors</span><span class="p">[</span><span class="n">zero_idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">counts</span><span class="p">[</span><span class="n">zero_idx</span><span class="p">]):</span>

                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Error in </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> spectrum: if the error on the background is zero, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;also the expected background counts must be zero&quot;</span>
                    <span class="p">)</span>

                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="n">observed_count_errors</span><span class="p">,</span> <span class="n">background_count_errors</span> <span class="o">=</span> <span class="n">error_tuple</span>

        <span class="k">return</span> <span class="n">observed_count_errors</span><span class="p">,</span> <span class="n">background_count_errors</span>

    <span class="k">def</span> <span class="nf">_probe_noise_models</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        probe the noise models</span>




<span class="sd">        :return: (observation_noise_model, background_noise_model)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">observation_noise_model</span><span class="p">,</span> <span class="n">background_noise_model</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># Now auto-probe the statistic to use</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">is_poisson</span><span class="p">:</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_observed_count_errors</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_observed_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_counts</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">int64</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">is_poisson</span><span class="p">:</span>

                    <span class="n">observation_noise_model</span> <span class="o">=</span> <span class="s2">&quot;poisson&quot;</span>
                    <span class="n">background_noise_model</span> <span class="o">=</span> <span class="s2">&quot;poisson&quot;</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_background_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_background_counts</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_counts</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>

                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error in PHA: negative counts!&quot;</span><span class="p">)</span>

                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_counts</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>

                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                            <span class="s2">&quot;Error in background spectrum: negative counts!&quot;</span>
                        <span class="p">)</span>

                        <span class="k">raise</span> <span class="n">NegativeBackground</span><span class="p">()</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="n">observation_noise_model</span> <span class="o">=</span> <span class="s2">&quot;poisson&quot;</span>
                    <span class="n">background_noise_model</span> <span class="o">=</span> <span class="s2">&quot;gaussian&quot;</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_counts</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>

                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                            <span class="s2">&quot;Error in background spectrum: negative background!&quot;</span>
                        <span class="p">)</span>

                        <span class="k">raise</span> <span class="n">NegativeBackground</span><span class="p">()</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">is_poisson</span><span class="p">:</span>

                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;We currently do not support Gaussian observation and Poisson background&quot;</span>
                    <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="n">observation_noise_model</span> <span class="o">=</span> <span class="s2">&quot;gaussian&quot;</span>
                    <span class="n">background_noise_model</span> <span class="o">=</span> <span class="s2">&quot;gaussian&quot;</span>

                    <span class="c1"># if not np.all(self._background_counts &gt;= 0):</span>
                    <span class="c1">#    raise NegativeBackground(</span>
                    <span class="c1">#        &quot;Error in background spectrum: negative background!&quot;</span>
                    <span class="c1">#    )</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># this is the case for no background</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_background_counts</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_back_count_errors</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_background_counts</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">is_poisson</span><span class="p">:</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_observed_count_errors</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_observed_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_counts</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">int64</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_counts</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>

                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error in PHA: negative counts!&quot;</span><span class="p">)</span>

                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_counts</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>

                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error in PHA: negative counts!&quot;</span><span class="p">)</span>

                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

                <span class="n">observation_noise_model</span> <span class="o">=</span> <span class="s2">&quot;poisson&quot;</span>
                <span class="n">background_noise_model</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">observation_noise_model</span> <span class="o">=</span> <span class="s2">&quot;gaussian&quot;</span>
                <span class="n">background_noise_model</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Print the auto-probed noise models</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Background modeled from plugin: </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span><span class="o">.</span><span class="n">name</span>
            <span class="p">)</span>

            <span class="n">bkg_noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span><span class="o">.</span><span class="n">observation_noise_model</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">bkg_noise</span> <span class="o">=</span> <span class="n">background_noise_model</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Auto-probed noise models:&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;- observation: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">observation_noise_model</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;- background: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">bkg_noise</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">observation_noise_model</span><span class="p">,</span> <span class="n">background_noise_model</span>

    <span class="k">def</span> <span class="nf">_background_setup</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">background</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">BinnedSpectrum</span><span class="p">,</span> <span class="n">XYLike</span><span class="p">,</span> <span class="s2">&quot;SpectrumLike&quot;</span><span class="p">],</span>
        <span class="n">observation</span><span class="p">:</span> <span class="n">BinnedSpectrum</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param background: background arguments (spectrum or plugin)</span>
<span class="sd">        :param observation: observed spectrum</span>
<span class="sd">        :return: (background_spectrum, background_plugin, background_counts, scaled_background_counts)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># this is only called during once during construction</span>

        <span class="c1"># setup up defaults as none</span>

        <span class="n">background_plugin</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">XYLike</span><span class="p">,</span> <span class="s2">&quot;SpectrumLike&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">background_spectrum</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">BinnedSpectrum</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">background_counts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">scaled_background_counts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_has_background</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">background</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_has_background</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># If this is a plugin created from a background</span>
            <span class="c1"># we extract the observed spectrum (it should not have a background...</span>
            <span class="c1">#  it is a background)</span>

            <span class="c1"># we are explicitly violating duck-typing</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">SpectrumLike</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">background</span><span class="p">,</span> <span class="n">XYLike</span>
            <span class="p">):</span>

                <span class="n">background_plugin</span> <span class="o">=</span> <span class="n">background</span>

                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;using a background plugin&quot;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># if the background is not a plugin then we need to make sure it is a spectrum</span>
                <span class="c1"># and that the spectrum is the same size as the observation</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">BinnedSpectrum</span><span class="p">):</span>

                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="s2">&quot;The background spectrum is not an instance of BinnedSpectrum&quot;</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">observation</span><span class="o">.</span><span class="n">n_channels</span> <span class="o">==</span> <span class="n">background</span><span class="o">.</span><span class="n">n_channels</span><span class="p">:</span>

                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="s2">&quot;Data file and background file have different &quot;</span>
                        <span class="s2">&quot;number of channels&quot;</span>
                    <span class="p">)</span>

                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

                <span class="n">background_spectrum</span> <span class="o">=</span> <span class="n">background</span>

                <span class="n">background_counts</span> <span class="o">=</span> <span class="n">background_spectrum</span><span class="o">.</span><span class="n">counts</span>

                <span class="c1"># this assumes the observed spectrum is already set!</span>

                <span class="n">scaled_background_counts</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_expected_background_counts_scaled</span><span class="p">(</span>
                        <span class="n">background_spectrum</span>
                    <span class="p">)</span>
                <span class="p">)</span>  <span class="c1"># type: np.ndarray</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">background_spectrum</span><span class="p">,</span>
            <span class="n">background_plugin</span><span class="p">,</span>
            <span class="n">background_counts</span><span class="p">,</span>
            <span class="n">scaled_background_counts</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_precalculations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        pre calculate values for speed.</span>

<span class="sd">        originally, the plugins were calculating these values on the fly, which was very slow</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Starting precalculations&quot;</span><span class="p">)</span>

        <span class="c1"># area scale factor between background and source</span>
        <span class="c1"># and exposure ratio between background and source</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>

            <span class="c1"># there is no background so the area scaling is unity</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;no background set in precalculations&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_area_ratio</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_exposure_ratio</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_background_scale_factor</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;background set in precalculations&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;detected background plugin&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span><span class="p">,</span> <span class="n">SpectrumLike</span><span class="p">):</span>

                    <span class="c1"># use the background plugin&#39;s observed spectrum  and exposure to scale the area and time</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_background_scale_factor</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span><span class="o">.</span><span class="n">observed_spectrum</span><span class="o">.</span><span class="n">scale_factor</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span><span class="o">.</span><span class="n">observed_spectrum</span><span class="o">.</span><span class="n">exposure</span>
                    <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="c1"># in this case, the XYLike data could come from anything, so area scaling is set to unity</span>
                    <span class="c1"># TODO: could this be wrong?</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_background_scale_factor</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">scale_factor</span>
                    <span class="p">)</span>

                    <span class="c1"># if the background exposure is set in the constructor, then this will scale it, otherwise</span>
                    <span class="c1"># this will be unity</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_exposure_ratio</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span>
                    <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_explict_background_exposure</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># this is the normal case with no background model, get the scale factor directly</span>

                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;this is a normal background observation&quot;</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_background_scale_factor</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">scale_factor</span>
                <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">exposure</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_area_ratio</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">scale_factor</span>
            <span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_scale_factor</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_exposure_ratio</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">exposure</span>
            <span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_total_scale_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area_ratio</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exposure_ratio</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;completed precalculations&quot;</span><span class="p">)</span>
        <span class="c1"># deal with background exposure and scale factor</span>
        <span class="c1"># we run through this separately to</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exposure</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exposure of the source spectrum</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">exposure</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">area_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: ratio between source and background area</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>

            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No background exists!&quot;</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area_ratio</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exposure_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :return:  ratio between source and background exposure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>

            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No background exists!&quot;</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exposure_ratio</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scale_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ratio between the source and the background exposure and area</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>

            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No background exists!&quot;</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_scale_factor</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">background_exposure</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exposure of the background spectrum, if present</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">background_scale_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The background scale factor</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_scale_factor</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">background_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedSpectrum</span><span class="p">:</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;This SpectrumLike instance has no background&quot;</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">background_plugin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; Optional[Union[SpectrumLike,XYLike] ]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">observed_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedSpectrum</span><span class="p">:</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_synthetic_plugin</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">observation</span><span class="p">:</span> <span class="n">BinnedSpectrum</span><span class="p">,</span>
        <span class="n">background</span><span class="p">,</span>
        <span class="n">source_function</span><span class="p">,</span>
        <span class="n">are_contiguous</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="n">speclike_gen</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="s2">&quot;generator&quot;</span><span class="p">,</span> <span class="n">observation</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">pts</span> <span class="o">=</span> <span class="n">PointSource</span><span class="p">(</span><span class="s2">&quot;fake&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">source_function</span><span class="p">)</span>

        <span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>

        <span class="n">speclike_gen</span><span class="o">.</span><span class="n">set_model</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">speclike_gen</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_build_fake_observation</span><span class="p">(</span>
        <span class="n">fake_data</span><span class="p">,</span>
        <span class="n">channel_set</span><span class="p">,</span>
        <span class="n">source_errors</span><span class="p">,</span>
        <span class="n">source_sys_errors</span><span class="p">,</span>
        <span class="n">is_poisson</span><span class="p">,</span>
        <span class="n">exposure</span><span class="p">,</span>
        <span class="n">scale_factor</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedSpectrum</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the fake observation builder for SpectrumLike which builds data</span>
<span class="sd">        for a binned spectrum without dispersion. It must be overridden in child classes.</span>

<span class="sd">        :param fake_data: series of values... they are ignored later</span>
<span class="sd">        :param channel_set: a channel set</span>
<span class="sd">        :param source_errors:</span>
<span class="sd">        :param source_sys_errors:</span>
<span class="sd">        :param is_poisson:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">observation</span> <span class="o">=</span> <span class="n">BinnedSpectrum</span><span class="p">(</span>
            <span class="n">fake_data</span><span class="p">,</span>
            <span class="n">exposure</span><span class="o">=</span><span class="n">exposure</span><span class="p">,</span>
            <span class="n">ebounds</span><span class="o">=</span><span class="n">channel_set</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span>
            <span class="n">count_errors</span><span class="o">=</span><span class="n">source_errors</span><span class="p">,</span>
            <span class="n">sys_errors</span><span class="o">=</span><span class="n">source_sys_errors</span><span class="p">,</span>
            <span class="n">quality</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">scale_factor</span><span class="o">=</span><span class="n">scale_factor</span><span class="p">,</span>
            <span class="n">is_poisson</span><span class="o">=</span><span class="n">is_poisson</span><span class="p">,</span>
            <span class="n">mission</span><span class="o">=</span><span class="s2">&quot;fake_mission&quot;</span><span class="p">,</span>
            <span class="n">instrument</span><span class="o">=</span><span class="s2">&quot;fake_instrument&quot;</span><span class="p">,</span>
            <span class="n">tstart</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="n">tstop</span><span class="o">=</span><span class="n">exposure</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">observation</span>

<div class="viewcode-block" id="SpectrumLike.from_background"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.from_background">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_background</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">spectrum_like</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract a SpectrumLike plugin from the background of another SpectrumLike (or subclass) instance</span>


<span class="sd">        :param name: name of the extracted_plugin</span>
<span class="sd">        :param spectrum_like: plugin with background to extract</span>
<span class="sd">        :param verbose: if the plugin should be verbose</span>
<span class="sd">        :return: SpectrumLike instance from the background</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;creating new spectrumlike from background&quot;</span><span class="p">)</span>

        <span class="n">background_only_spectrum</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span>
            <span class="n">spectrum_like</span><span class="o">.</span><span class="n">background_spectrum</span>
        <span class="p">)</span>

        <span class="n">background_spectrum_like</span> <span class="o">=</span> <span class="n">SpectrumLike</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">observation</span><span class="o">=</span><span class="n">background_only_spectrum</span><span class="p">,</span>
            <span class="n">background</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">background_spectrum_like</span></div>

<div class="viewcode-block" id="SpectrumLike.from_function"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.from_function">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_function</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">source_function</span><span class="p">,</span>
        <span class="n">energy_min</span><span class="p">,</span>
        <span class="n">energy_max</span><span class="p">,</span>
        <span class="n">source_errors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">source_sys_errors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">background_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">background_errors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">background_sys_errors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exposure</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">scale_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Construct a simulated spectrum from a given source function and (optional) background function. If source and/or background errors are not supplied, the likelihood is assumed to be Poisson.</span>

<span class="sd">        :param name: simulkated data set name</span>
<span class="sd">        :param source_function: astromodels function</span>
<span class="sd">        :param energy_min: array of low energy bin edges</span>
<span class="sd">        :param energy_max: array of high energy bin edges</span>
<span class="sd">        :param source_errors: (optional) gaussian source errors</span>
<span class="sd">        :param source_sys_errors: (optional) systematic source errors</span>
<span class="sd">        :param background_function: (optional) astromodels background function</span>
<span class="sd">        :param background_errors: (optional) gaussian background errors</span>
<span class="sd">        :param background_sys_errors: (optional) background systematic errors</span>
<span class="sd">        :param exposure: the exposure to assume</span>
<span class="sd">        :param scale_factor: the scale factor between source exposure / bkg exposure</span>
<span class="sd">        :return: simulated SpectrumLike plugin</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;creating new spectrumlike from function&quot;</span><span class="p">)</span>

        <span class="n">channel_set</span> <span class="o">=</span> <span class="n">ChannelSet</span><span class="o">.</span><span class="n">from_starts_and_stops</span><span class="p">(</span><span class="n">energy_min</span><span class="p">,</span> <span class="n">energy_max</span><span class="p">)</span>

        <span class="c1"># this is just for construction</span>

        <span class="n">fake_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">energy_min</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">source_errors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">is_poisson</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_errors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">energy_min</span><span class="p">):</span>

                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;source error array is not the same dimension as the energy array&quot;</span>
                <span class="p">)</span>

                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

            <span class="n">is_poisson</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">source_sys_errors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_sys_errors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">energy_min</span><span class="p">):</span>

                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;background systematic error array is not the same dimension as the energy array&quot;</span>
                <span class="p">)</span>

                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="c1"># call the class dependent observation builder</span>

        <span class="n">observation</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_build_fake_observation</span><span class="p">(</span>
            <span class="n">fake_data</span><span class="p">,</span>
            <span class="n">channel_set</span><span class="p">,</span>
            <span class="n">source_errors</span><span class="p">,</span>
            <span class="n">source_sys_errors</span><span class="p">,</span>
            <span class="n">is_poisson</span><span class="p">,</span>
            <span class="n">exposure</span><span class="p">,</span>
            <span class="n">scale_factor</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">background_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">fake_background</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">energy_min</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">background_errors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="n">is_poisson</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">background_errors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">energy_min</span><span class="p">):</span>

                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="s2">&quot;background error array is not the same dimension as the energy array&quot;</span>
                    <span class="p">)</span>

                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

                <span class="n">is_poisson</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">background_sys_errors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">background_sys_errors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">energy_min</span><span class="p">):</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="s2">&quot;background systematic error array is not the same dimension as the energy array&quot;</span>
                    <span class="p">)</span>

                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

            <span class="n">tmp_background</span> <span class="o">=</span> <span class="n">BinnedSpectrum</span><span class="p">(</span>
                <span class="n">fake_background</span><span class="p">,</span>
                <span class="n">exposure</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="n">ebounds</span><span class="o">=</span><span class="n">channel_set</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span>
                <span class="n">count_errors</span><span class="o">=</span><span class="n">background_errors</span><span class="p">,</span>
                <span class="n">sys_errors</span><span class="o">=</span><span class="n">background_sys_errors</span><span class="p">,</span>
                <span class="n">quality</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">scale_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="n">is_poisson</span><span class="o">=</span><span class="n">is_poisson</span><span class="p">,</span>
                <span class="n">mission</span><span class="o">=</span><span class="s2">&quot;fake_mission&quot;</span><span class="p">,</span>
                <span class="n">instrument</span><span class="o">=</span><span class="s2">&quot;fake_instrument&quot;</span><span class="p">,</span>
                <span class="n">tstart</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                <span class="n">tstop</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># now we have to generate the background counts</span>
            <span class="c1"># we treat the background as a simple observation with no</span>
            <span class="c1"># other background</span>

            <span class="n">background_gen</span> <span class="o">=</span> <span class="n">SpectrumLike</span><span class="p">(</span>
                <span class="s2">&quot;generator&quot;</span><span class="p">,</span> <span class="n">tmp_background</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

            <span class="n">pts_background</span> <span class="o">=</span> <span class="n">PointSource</span><span class="p">(</span>
                <span class="s2">&quot;fake_background&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">background_function</span>
            <span class="p">)</span>

            <span class="n">background_model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">pts_background</span><span class="p">)</span>

            <span class="n">background_gen</span><span class="o">.</span><span class="n">set_model</span><span class="p">(</span><span class="n">background_model</span><span class="p">)</span>

            <span class="n">sim_background</span> <span class="o">=</span> <span class="n">background_gen</span><span class="o">.</span><span class="n">get_simulated_dataset</span><span class="p">(</span><span class="s2">&quot;fake&quot;</span><span class="p">)</span>

            <span class="n">background</span> <span class="o">=</span> <span class="n">sim_background</span><span class="o">.</span><span class="n">_observed_spectrum</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">background</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">generator</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_synthetic_plugin</span><span class="p">(</span>
            <span class="n">observation</span><span class="p">,</span>
            <span class="n">background</span><span class="p">,</span>
            <span class="n">source_function</span><span class="p">,</span>
        <span class="p">)</span>  <span class="c1"># type: SpectrumLike</span>

        <span class="k">return</span> <span class="n">generator</span><span class="o">.</span><span class="n">get_simulated_dataset</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpectrumLike.assign_to_source"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.assign_to_source">[docs]</a>    <span class="k">def</span> <span class="nf">assign_to_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign these data to the given source (instead of to the sum of all sources, which is the default)</span>

<span class="sd">        :param source_name: name of the source (must be contained in the likelihood model)</span>
<span class="sd">        :return: none</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_like_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">source_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_like_model</span><span class="o">.</span><span class="n">sources</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;Source </span><span class="si">%s</span><span class="s2"> is not contained in &quot;</span>
                    <span class="s2">&quot;the likelihood model&quot;</span> <span class="o">%</span> <span class="n">source_name</span>
                <span class="p">)</span>

                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_source_name</span> <span class="o">=</span> <span class="n">source_name</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">likelihood_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Model</span><span class="p">:</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_like_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plugin </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s2"> does not have a likelihood model&quot;</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_like_model</span>

<div class="viewcode-block" id="SpectrumLike.get_pha_files"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.get_pha_files">[docs]</a>    <span class="k">def</span> <span class="nf">get_pha_files</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">BinnedSpectrum</span><span class="p">]:</span>

        <span class="n">info</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">BinnedSpectrum</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># we want to pass copies so that</span>
        <span class="c1"># the user doesn&#39;t grab the instance</span>
        <span class="c1"># and try to modify things. protection</span>
        <span class="n">info</span><span class="p">[</span><span class="s2">&quot;pha&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">info</span><span class="p">[</span><span class="s2">&quot;bak&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">info</span></div>

<div class="viewcode-block" id="SpectrumLike.set_active_measurements"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.set_active_measurements">[docs]</a>    <span class="k">def</span> <span class="nf">set_active_measurements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the measurements to be used during the analysis. Use as many ranges as you need, and you can specify</span>
<span class="sd">        either energies or channels to be used.</span>

<span class="sd">        NOTE to Xspec users: while XSpec uses integers and floats to distinguish between energies and channels</span>
<span class="sd">        specifications, 3ML does not, as it would be error-prone when writing scripts. Read the following documentation</span>
<span class="sd">        to know how to achieve the same functionality.</span>

<span class="sd">        * Energy selections:</span>

<span class="sd">        They are specified as &#39;emin-emax&#39;. Energies are in keV. Example:</span>

<span class="sd">        set_active_measurements(&#39;10-12.5&#39;,&#39;56.0-100.0&#39;)</span>

<span class="sd">        which will set the energy range 10-12.5 keV and 56-100 keV to be</span>
<span class="sd">        used in the analysis. Note that there is no difference in saying 10 or 10.0.</span>

<span class="sd">        * Channel selections:</span>

<span class="sd">        They are specified as &#39;c[channel min]-c[channel max]&#39;. Example:</span>

<span class="sd">        set_active_measurements(&#39;c10-c12&#39;,&#39;c56-c100&#39;)</span>

<span class="sd">        This will set channels 10-12 and 56-100 as active channels to be used in the analysis</span>

<span class="sd">        * Mixed channel and energy selections:</span>

<span class="sd">        You can also specify mixed energy/channel selections, for example to go from 0.2 keV to channel 20 and from</span>
<span class="sd">        channel 50 to 10 keV:</span>

<span class="sd">        set_active_measurements(&#39;0.2-c10&#39;,&#39;c50-10&#39;)</span>

<span class="sd">        * Use all measurements (i.e., reset to initial state):</span>

<span class="sd">        Use &#39;all&#39; to select all measurements, as in:</span>

<span class="sd">        set_active_measurements(&#39;all&#39;)</span>

<span class="sd">        Use &#39;reset&#39; to return to native PHA quality from file, as in:</span>

<span class="sd">        set_active_measurements(&#39;reset&#39;)</span>


<span class="sd">        * Exclude measurements:</span>

<span class="sd">        Excluding measurements work as selecting measurements, but with the &quot;exclude&quot; keyword set to the energies and/or</span>
<span class="sd">        channels to be excluded. To exclude between channel 10 and 20 keV and 50 keV to channel 120 do:</span>

<span class="sd">        set_active_measurements(exclude=[&quot;c10-20&quot;, &quot;50-c120&quot;])</span>

<span class="sd">        * Select and exclude:</span>

<span class="sd">        Call this method more than once if you need to select and exclude. For example, to select between 0.2 keV and</span>
<span class="sd">        channel 10, but exclude channel 30-50 and energy , do:</span>

<span class="sd">        set_active_measurements(&quot;0.2-c10&quot;,exclude=[&quot;c30-c50&quot;])</span>

<span class="sd">        * Using native PHA quality:</span>

<span class="sd">        To simply add or exclude channels from the native PHA, one can use the use_quailty</span>
<span class="sd">        option:</span>

<span class="sd">        set_active_measurements(</span>
<span class="sd">            &quot;0.2-c10&quot;,exclude=[&quot;c30-c50&quot;], use_quality=True)</span>

<span class="sd">        This translates to including the channels from 0.2 keV - channel 10, exluding channels</span>
<span class="sd">        30-50 and any channels flagged BAD in the PHA file will also be excluded.</span>



<span class="sd">        :param args:</span>
<span class="sd">        :param exclude: (list) exclude the provided channel/energy ranges</span>
<span class="sd">        :param use_quality: (bool) use the native quality on the PHA file (default=False)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># To implement this we will use an array of boolean index,</span>
        <span class="c1"># which will filter</span>
        <span class="c1"># out the non-used channels during the logLike</span>

        <span class="c1"># Now build the new mask: values for which the mask is 0 will be masked</span>

        <span class="c1"># We will build the high res mask even if we are</span>
        <span class="c1"># already rebinned so that it can be saved</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;You cannot select active measurements if you have a rebinning active. &quot;</span>
                <span class="s2">&quot;Remove it first with remove_rebinning&quot;</span>
            <span class="p">)</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="k">if</span> <span class="s2">&quot;use_quality&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>

            <span class="n">use_quality</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;use_quality&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">use_quality</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">use_quality</span><span class="p">:</span>

            <span class="c1"># Start with quality mask. This means that channels</span>
            <span class="c1"># marked good by quality will be used unless exluded in the arguments</span>
            <span class="c1"># and channels marked bad by quality will be excluded unless included</span>
            <span class="c1"># by the arguments</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">quality</span><span class="o">.</span><span class="n">good</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># otherwise, we will start out with all channels deselected</span>
            <span class="c1"># and turn the on/off by the arguments</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;all&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>

            <span class="c1"># Just make sure than no further selections have been made.</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>

                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;If you specify &#39;all&#39;, you cannot specify more than one energy range.&quot;</span>
                <span class="p">)</span>

                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

            <span class="c1"># Convert the mask to all True (we use all channels)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="s2">&quot;reset&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>

            <span class="c1"># Convert the to native PHA masking specified in quality</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>

                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;If you specify &#39;reset&#39;, you cannot specify more than one energy range.&quot;</span>
                <span class="p">)</span>

                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">quality</span><span class="o">.</span><span class="n">good</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>

                <span class="n">selections</span> <span class="o">=</span> <span class="n">dash_separated_string_to_tuple</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

                <span class="c1"># We need to find out if it is a channel or and energy being requested</span>

                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">selections</span><span class="p">):</span>

                    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>

                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                            <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">n_channels</span>
                        <span class="p">):</span>

                            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;%s is larger than the number of channels: %d&quot;</span>
                                <span class="o">%</span> <span class="p">(</span>
                                    <span class="n">s</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">n_channels</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="p">)</span>

                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

                        <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

                    <span class="k">else</span><span class="p">:</span>

                        <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">containing_bin</span><span class="p">(</span>
                            <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                        <span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>

                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="s2">&quot;The channel and energy selection (</span><span class="si">%s</span><span class="s2">) are out of order and translates to </span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">selections</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="p">)</span>

                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

                <span class="c1"># we do the opposite of the exclude command!</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Range </span><span class="si">%s</span><span class="s2"> translates to channels </span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>

        <span class="c1"># If you are just excluding channels</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="s2">&quot;exclude&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>

            <span class="n">exclude</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;exclude&quot;</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">:</span>

                <span class="n">selections</span> <span class="o">=</span> <span class="n">dash_separated_string_to_tuple</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

                <span class="c1"># We need to find out if it is a channel or and energy being requested</span>

                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">selections</span><span class="p">):</span>

                    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>

                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                            <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">n_channels</span>
                        <span class="p">):</span>

                            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is larger than the number of channels: </span><span class="si">%d</span><span class="s2">&quot;</span>
                                <span class="o">%</span> <span class="p">(</span>
                                    <span class="n">s</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">n_channels</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="p">)</span>

                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

                        <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

                    <span class="k">else</span><span class="p">:</span>

                        <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">containing_bin</span><span class="p">(</span>
                            <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                        <span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>

                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="s2">&quot;The channel and energy selection (</span><span class="si">%s</span><span class="s2">) are out of order and translate to </span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">selections</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

                <span class="c1"># we do the opposite of the exclude command!</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Range </span><span class="si">%s</span><span class="s2"> translates to excluding channels </span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>

            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Now using </span><span class="si">%s</span><span class="s2"> channels out of </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">n_channels</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Apply the mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_mask_to_original_vectors</span><span class="p">()</span>

        <span class="c1"># if the user did not specify use_quality, they may have selected channels which</span>
        <span class="c1"># are marked BAD (5) in the native PHA file. We want to warn them in this case only (or maybe in all cases?)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_quality</span><span class="p">:</span>

            <span class="n">number_of_native_good_channels</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">quality</span><span class="o">.</span><span class="n">good</span>
            <span class="p">)</span>
            <span class="n">number_of_user_good_channels</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">number_of_user_good_channels</span> <span class="o">&gt;</span> <span class="n">number_of_native_good_channels</span><span class="p">:</span>

                <span class="c1"># we have more good channels than specified in the PHA file</span>
                <span class="c1"># so we need to figure out which channels these are where excluded</span>

                <span class="n">deselected_channels</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">n_channels</span><span class="p">):</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">quality</span><span class="o">.</span><span class="n">bad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">deselected_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;You have opted to use channels which are flagged BAD in the PHA file.&quot;</span>
                <span class="p">)</span>

                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;These channels are: </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">deselected_channels</span><span class="p">]))</span>
                <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_apply_mask_to_original_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># Apply the mask</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_current_observed_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_counts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_count_errors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_observed_count_errors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_count_errors</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_current_background_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_counts</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_scaled_background_counts</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_background_counts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_back_count_errors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_current_back_count_errors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_back_count_errors</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
                <span class="p">]</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">_without_mask_nor_rebinner</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="c1"># Store mask and rebinner for later use</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="n">rebinner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span>

        <span class="c1"># Clean mask and rebinning</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">remove_rebinning</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_active_measurements</span><span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>

        <span class="c1"># Execute whathever</span>

        <span class="k">yield</span>

        <span class="c1"># Restore mask and rebinner (if any)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span>

        <span class="k">if</span> <span class="n">rebinner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># There was a rebinner, use it. Note that the rebinner applies the mask by itself</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_apply_rebinner</span><span class="p">(</span><span class="n">rebinner</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># There was no rebinner, so we need to explicitly apply the mask</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_apply_mask_to_original_vectors</span><span class="p">()</span>

<div class="viewcode-block" id="SpectrumLike.get_simulated_dataset"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.get_simulated_dataset">[docs]</a>    <span class="k">def</span> <span class="nf">get_simulated_dataset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">store_model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;SpectrumLike&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns another Binned instance where data have been obtained by randomizing the current expectation from the</span>
<span class="sd">        model, as well as from the background (depending on the respective noise models)</span>

<span class="sd">        :param new_name: the base line name</span>
<span class="sd">        :param store_model: to store the model configuration used to simulate the data set</span>
<span class="sd">        :return: an BinnedSpectrum or child instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_like_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;You need to set up a model before randomizing&quot;</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="c1"># Keep track of how many syntethic datasets we have generated</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n_synthetic_datasets</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;now have </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_synthetic_datasets</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Generate a name for the new dataset if needed</span>
        <span class="k">if</span> <span class="n">new_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_sim_</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_synthetic_datasets</span><span class="p">)</span>

        <span class="c1"># Generate randomized data depending on the different noise models</span>

        <span class="c1"># We remove the mask temporarily because we need the various elements for all channels. We will restore it</span>
        <span class="c1"># at the end</span>

        <span class="n">original_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">original_rebinner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_without_mask_nor_rebinner</span><span class="p">():</span>

            <span class="c1"># Get the source model for all channels (that&#39;s why we don&#39;t use the .folded_model property)</span>

            <span class="n">source_model_counts</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_model</span><span class="p">()</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nuisance_parameter</span><span class="o">.</span><span class="n">value</span>
            <span class="p">)</span>

            <span class="c1"># sometimes the first channel has ZERO</span>
            <span class="c1"># for its lower bound which can cause</span>
            <span class="c1"># an inf or NaN for a given model</span>

            <span class="c1"># we will set that to zero (better solution??)</span>
            <span class="c1"># this should not affect most instruments as</span>
            <span class="c1"># this is usually a crappy channel in the first</span>
            <span class="c1"># place</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">source_model_counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

                <span class="n">source_model_counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;simulated spectrum had infinite counts in first channel&quot;</span>
                <span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;setting to ZERO&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">source_model_counts</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_observation_noise_model</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span>
            <span class="p">):</span>

                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;there are negative counts for this simulation&quot;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_like_model</span><span class="o">.</span><span class="n">free_parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">source_model_counts</span><span class="p">)):</span>

                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;there are NaN counts for this simulation&quot;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_like_model</span><span class="o">.</span><span class="n">free_parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

            <span class="c1"># The likelihood evaluator keeps track of the proper likelihood needed to randomize</span>
            <span class="c1"># quantities. It properly returns None if needed. This avoids multiple checks and dupilcate</span>
            <span class="c1"># code for the MANY cases we can have. As new cases are added, this code will adapt.</span>

            <span class="n">randomized_source_counts</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_evaluator</span><span class="o">.</span><span class="n">get_randomized_source_counts</span><span class="p">(</span>
                    <span class="n">source_model_counts</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">randomized_source_count_err</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_evaluator</span><span class="o">.</span><span class="n">get_randomized_source_errors</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">randomized_background_counts</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_evaluator</span><span class="o">.</span><span class="n">get_randomized_background_counts</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">randomized_background_count_err</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_evaluator</span><span class="o">.</span><span class="n">get_randomized_background_errors</span><span class="p">()</span>
            <span class="p">)</span>

            <span class="c1"># create new source and background spectra</span>
            <span class="c1"># the children of BinnedSpectra must properly override the new_spectrum</span>
            <span class="c1"># member so as to build the appropriate spectrum type. All parameters of the current</span>
            <span class="c1"># spectrum remain the same except for the rate and rate errors</span>

            <span class="c1"># the profile likelihood automatically adjust the background spectrum to the</span>
            <span class="c1"># same exposure and scale as the observation</span>
            <span class="c1"># therefore, we must  set the background simulation to have the exposure and scale</span>
            <span class="c1"># of the observation</span>

            <span class="n">new_observation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span>
                <span class="n">new_counts</span><span class="o">=</span><span class="n">randomized_source_counts</span><span class="p">,</span>
                <span class="n">new_count_errors</span><span class="o">=</span><span class="n">randomized_source_count_err</span><span class="p">,</span>
                <span class="n">new_scale_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="n">new_background</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span>
                    <span class="n">new_counts</span><span class="o">=</span><span class="n">randomized_background_counts</span><span class="p">,</span>
                    <span class="n">new_count_errors</span><span class="o">=</span><span class="n">randomized_background_count_err</span><span class="p">,</span>
                    <span class="n">new_exposure</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">exposure</span><span class="p">,</span>  <span class="c1"># because it was adjusted</span>
                    <span class="c1"># new_scale_factor=1.0,  # because it was adjusted</span>
                    <span class="n">new_scale_factor</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_scale_factor</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;made </span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="n">randomized_background_counts</span><span class="p">)</span><span class="si">}</span><span class="s2"> bkg counts&quot;</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="n">new_background</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_evaluator</span><span class="o">.</span><span class="n">synthetic_background_plugin</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">new_background</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Now create another instance of BinnedSpectrum with the randomized data we just generated</span>
            <span class="c1"># notice that the _new member is a classmethod</span>
            <span class="c1"># (we use verbose=False to avoid many messages when doing many simulations)</span>
            <span class="n">new_spectrum_plugin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_plugin</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">new_name</span><span class="p">,</span>
                <span class="n">observation</span><span class="o">=</span><span class="n">new_observation</span><span class="p">,</span>
                <span class="n">background</span><span class="o">=</span><span class="n">new_background</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Apply the same selections as the current data set</span>
            <span class="k">if</span> <span class="n">original_rebinner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># Apply rebinning, which also applies the mask</span>
                <span class="n">new_spectrum_plugin</span><span class="o">.</span><span class="n">_apply_rebinner</span><span class="p">(</span><span class="n">original_rebinner</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># Only apply the mask</span>
                <span class="n">new_spectrum_plugin</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">original_mask</span>
                <span class="n">new_spectrum_plugin</span><span class="o">.</span><span class="n">_apply_mask_to_original_vectors</span><span class="p">()</span>

            <span class="c1"># We want to store the simulated parameters so that the user</span>
            <span class="c1"># can recall them later</span>
            <span class="k">if</span> <span class="n">store_model</span><span class="p">:</span>

                <span class="n">new_spectrum_plugin</span><span class="o">.</span><span class="n">_simulation_storage</span> <span class="o">=</span> <span class="n">clone_model</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_like_model</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">new_spectrum_plugin</span><span class="o">.</span><span class="n">_simulation_storage</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># TODO: nuisance parameters</span>

            <span class="k">return</span> <span class="n">new_spectrum_plugin</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_new_plugin</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        allows for constructing a new plugin of the appropriate</span>
<span class="sd">        type in conjunction with the Spectrum.clone method.</span>
<span class="sd">        It is used for example in get_simulated_dataset</span>

<span class="sd">        new_background = self._background_spectrum.clone(new_counts=randomized_background_counts,</span>
<span class="sd">                                                  new_count_errors=randomized_background_count_err)</span>


<span class="sd">        new_spectrum_plugin = self._new_plugin(name=new_name,</span>
<span class="sd">                                               observation=new_observation,</span>
<span class="sd">                                               background=new_background,</span>
<span class="sd">                                               verbose=self._verbose,</span>
<span class="sd">                                               **kwargs)</span>


<span class="sd">        :param args:</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">simulated_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Model</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the simulated dataset parameters</span>
<span class="sd">        :return: a likelihood model copy</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulation_storage</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;This is not a simulated data set&quot;</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulation_storage</span>

<div class="viewcode-block" id="SpectrumLike.rebin_on_background"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.rebin_on_background">[docs]</a>    <span class="k">def</span> <span class="nf">rebin_on_background</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_number_of_counts</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rebin the spectrum guaranteeing the provided minimum number of counts in each background bin. This is usually</span>
<span class="sd">        required for spectra with very few background counts to make the Poisson profile likelihood meaningful.</span>
<span class="sd">        Of course this is not relevant if you treat the background as ideal, nor if the background spectrum has</span>
<span class="sd">        Gaussian errors.</span>

<span class="sd">        The observed spectrum will be rebinned in the same fashion as the background spectrum.</span>

<span class="sd">        To neutralize this completely, use &quot;remove_rebinning&quot;</span>

<span class="sd">        :param min_number_of_counts: the minimum number of counts in each bin</span>
<span class="sd">        :return: none</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># NOTE: the rebinner takes care of the mask already</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;This data has no background, cannot rebin on background!&quot;</span>
            <span class="p">)</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="n">rebinner</span><span class="p">:</span> <span class="n">Rebinner</span> <span class="o">=</span> <span class="n">Rebinner</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_background_counts</span><span class="p">,</span> <span class="n">min_number_of_counts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">rebinner</span><span class="o">.</span><span class="n">n_bins</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">):</span>

            <span class="c1"># only for the PHASpectrum subclass do we need to update the the grouping</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="p">,</span> <span class="n">PHASpectrum</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">set_ogip_grouping</span><span class="p">(</span><span class="n">rebinner</span><span class="o">.</span><span class="n">grouping</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">set_ogip_grouping</span><span class="p">(</span><span class="n">rebinner</span><span class="o">.</span><span class="n">grouping</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_apply_rebinner</span><span class="p">(</span><span class="n">rebinner</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;rebinning had no effect&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpectrumLike.rebin_on_source"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.rebin_on_source">[docs]</a>    <span class="k">def</span> <span class="nf">rebin_on_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_number_of_counts</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rebin the spectrum guaranteeing the provided minimum number of counts in each source bin.</span>

<span class="sd">        To neutralize this completely, use &quot;remove_rebinning&quot;</span>

<span class="sd">        :param min_number_of_counts: the minimum number of counts in each bin</span>
<span class="sd">        :return: none</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># NOTE: the rebinner takes care of the mask already</span>

        <span class="n">rebinner</span> <span class="o">=</span> <span class="n">Rebinner</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_observed_counts</span><span class="p">,</span> <span class="n">min_number_of_counts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">rebinner</span><span class="o">.</span><span class="n">n_bins</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">):</span>

            <span class="c1"># only for the PHASpectrum subclass do we need to update the the grouping</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="p">,</span> <span class="n">PHASpectrum</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">set_ogip_grouping</span><span class="p">(</span><span class="n">rebinner</span><span class="o">.</span><span class="n">grouping</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">set_ogip_grouping</span><span class="p">(</span>
                        <span class="n">rebinner</span><span class="o">.</span><span class="n">grouping</span>
                    <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_apply_rebinner</span><span class="p">(</span><span class="n">rebinner</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;rebinning had no effect&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_apply_rebinner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rebinner</span><span class="p">:</span> <span class="n">Rebinner</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span> <span class="o">=</span> <span class="n">rebinner</span>

        <span class="c1"># Apply the rebinning to everything.</span>
        <span class="c1"># NOTE: the output of the .rebin method are the vectors with the mask *already applied*</span>

        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_observed_counts</span><span class="p">,)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_observed_counts</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_count_errors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_current_observed_count_errors</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span><span class="o">.</span><span class="n">rebin_errors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_count_errors</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_current_background_counts</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_current_scaled_background_counts</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_background_counts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_background_counts</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_back_count_errors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># NOTE: the output of the .rebin method are the vectors with the mask *already applied*</span>

                <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_current_back_count_errors</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span><span class="o">.</span><span class="n">rebin_errors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_back_count_errors</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Now using </span><span class="si">%s</span><span class="s2"> bins&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span><span class="o">.</span><span class="n">n_bins</span><span class="p">)</span>

<div class="viewcode-block" id="SpectrumLike.remove_rebinning"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.remove_rebinning">[docs]</a>    <span class="k">def</span> <span class="nf">remove_rebinning</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the rebinning scheme set with rebin_on_background.</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Restore original vectors with mask applied</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_mask_to_original_vectors</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_get_expected_background_counts_scaled</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">background_spectrum</span><span class="p">:</span> <span class="n">BinnedSpectrum</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the background counts expected in the source interval and in the source region, based on the observed</span>
<span class="sd">        background.</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># NOTE : this is called only once during construction!</span>

        <span class="c1"># The scale factor is the ratio between the collection area of the source spectrum and the</span>
        <span class="c1"># background spectrum. It is used for example for the typical aperture-photometry method used in</span>
        <span class="c1"># X-ray astronomy, where the background region has a different size with respect to the source region</span>

        <span class="n">scale_factor</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">scale_factor</span>
            <span class="o">/</span> <span class="n">background_spectrum</span><span class="o">.</span><span class="n">scale_factor</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># The expected number of counts is the rate in the background file multiplied by its exposure, renormalized</span>
        <span class="c1"># by the scale factor.</span>
        <span class="c1"># (see http://heasarc.gsfc.nasa.gov/docs/asca/abc_backscal.html)</span>

        <span class="n">bkg_counts</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">background_spectrum</span><span class="o">.</span><span class="n">rates</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">exposure</span>
            <span class="o">*</span> <span class="n">scale_factor</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">bkg_counts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_observed_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_observed_counts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_background_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_background_counts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_scaled_background_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_scaled_background_counts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_background_count_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_back_count_errors</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_observed_count_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_observed_count_errors</span>

    <span class="k">def</span> <span class="nf">_set_background_noise_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_model</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="c1"># Do not make differences between upper and lower cases</span>
        <span class="k">if</span> <span class="n">new_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_model</span> <span class="o">=</span> <span class="n">new_model</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">new_model</span> <span class="ow">in</span> <span class="n">_known_noise_models</span><span class="p">):</span>

                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;Noise model </span><span class="si">%s</span><span class="s2"> not recognized. &quot;</span>
                    <span class="s2">&quot;Allowed models are: </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="o">%</span> <span class="p">(</span>
                        <span class="n">new_model</span><span class="p">,</span>
                        <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_known_noise_models</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">)</span>

                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">=</span> <span class="n">new_model</span>

        <span class="c1"># reset the likelihood</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_evaluator</span> <span class="o">=</span> <span class="n">statistic_lookup</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_observation_noise_model</span>
        <span class="p">][</span><span class="n">new_model</span><span class="p">](</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;You are setting the background noise model to something that is not specified in the spectrum.</span><span class="se">\</span>
<span class="s2">         Verify that this makes statistical sense.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_background_noise_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span>

    <span class="n">background_noise_model</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span>
        <span class="n">_get_background_noise_model</span><span class="p">,</span>
        <span class="n">_set_background_noise_model</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Sets/gets the noise model for the background spectrum&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_observation_noise_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_model</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="c1"># Do not make differences between upper and lower cases</span>
        <span class="n">new_model</span> <span class="o">=</span> <span class="n">new_model</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">new_model</span> <span class="ow">in</span> <span class="n">_known_noise_models</span><span class="p">):</span>

            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Noise model </span><span class="si">%s</span><span class="s2"> not recognized. &quot;</span>
                <span class="s2">&quot;Allowed models are: </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span>
                    <span class="n">new_model</span><span class="p">,</span>
                    <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_known_noise_models</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_observation_noise_model</span> <span class="o">=</span> <span class="n">new_model</span>

        <span class="c1"># reset the likelihood</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_evaluator</span> <span class="o">=</span> <span class="n">statistic_lookup</span><span class="p">[</span><span class="n">new_model</span><span class="p">][</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span>
        <span class="p">](</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;You are setting the observation noise model to something that is not specified in the spectrum.</span><span class="se">\</span>
<span class="s2">                 Verify that this makes statistical sense.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_observation_noise_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observation_noise_model</span>

    <span class="n">observation_noise_model</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span>
        <span class="n">_get_observation_noise_model</span><span class="p">,</span>
        <span class="n">_set_observation_noise_model</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Sets/gets the noise model for the background spectrum&quot;</span><span class="p">,</span>
    <span class="p">)</span>

<div class="viewcode-block" id="SpectrumLike.get_log_like"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.get_log_like">[docs]</a>    <span class="k">def</span> <span class="nf">get_log_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">precalc_fluxes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls the likelihood from the pre-setup likelihood evaluator that &quot;knows&quot; of the currently set</span>
<span class="sd">        noise models</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">loglike</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood_evaluator</span><span class="o">.</span><span class="n">get_current_value</span><span class="p">(</span>
            <span class="n">precalc_fluxes</span><span class="o">=</span><span class="n">precalc_fluxes</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exclude_from_fit</span><span class="p">:</span> <span class="n">loglike</span><span class="o">*=</span><span class="mi">0</span>
        <span class="k">return</span> <span class="n">loglike</span></div>

<div class="viewcode-block" id="SpectrumLike.inner_fit"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.inner_fit">[docs]</a>    <span class="k">def</span> <span class="nf">inner_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_log_like</span><span class="p">()</span></div>

<div class="viewcode-block" id="SpectrumLike.set_model"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.set_model">[docs]</a>    <span class="k">def</span> <span class="nf">set_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">likelihoodModel</span><span class="p">:</span> <span class="n">Model</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the model to be used in the joint minimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Store likelihood model</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_like_model</span> <span class="o">=</span> <span class="n">likelihoodModel</span>

        <span class="c1"># We assume there are no extended sources, since we cannot handle them here</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_like_model</span><span class="o">.</span><span class="n">get_number_of_extended_sources</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;SpectrumLike plugins do not support &quot;</span> <span class="s2">&quot;extended sources&quot;</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="c1"># check if we set a source name that the source is in the model</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_like_model</span><span class="o">.</span><span class="n">sources</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;Source </span><span class="si">%s</span><span class="s2"> is not contained in &quot;</span>
                    <span class="s2">&quot;the likelihood model&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_name</span>
                <span class="p">)</span>

                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>
        <span class="c1"># Get the differential flux function, and the integral function, with no dispersion,</span>
        <span class="c1"># we simply integrate the model over the bins</span>

        <span class="n">differential_flux</span><span class="p">,</span> <span class="n">integral</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_diff_flux_and_integral</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_like_model</span><span class="p">,</span> <span class="n">integrate_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_integrate_method</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_integral_flux</span> <span class="o">=</span> <span class="n">integral</span></div>

    <span class="k">def</span> <span class="nf">_evaluate_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">precalc_fluxes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Since there is no dispersion, we simply evaluate the model by integrating over the energy bins.</span>
<span class="sd">        This can be overloaded to convolve the model with a response, for example</span>


<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">precalc_fluxes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">precalc_fluxes</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_contiguous_energies</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predefined_energies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_integral_flux</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_integral_flux</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_integral_flux</span><span class="p">(</span><span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">emin</span><span class="p">,</span> <span class="n">emax</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">bin_stack</span>
                <span class="p">]</span>
            <span class="p">)</span>

<div class="viewcode-block" id="SpectrumLike.get_model"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.get_model">[docs]</a>    <span class="k">def</span> <span class="nf">get_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">precalc_fluxes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The model integrated over the energy bins. Note that it only returns the  model for the</span>
<span class="sd">        currently active channels/measurements</span>

<span class="sd">        :return: array of folded model</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="p">(</span><span class="n">model</span><span class="p">,)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_model</span><span class="p">(</span><span class="n">precalc_fluxes</span><span class="o">=</span><span class="n">precalc_fluxes</span><span class="p">)</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">exposure</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">model</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_model</span><span class="p">(</span><span class="n">precalc_fluxes</span><span class="o">=</span><span class="n">precalc_fluxes</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">]</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">exposure</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nuisance_parameter</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">model</span></div>

    <span class="k">def</span> <span class="nf">_evaluate_background_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Since there is no dispersion, we simply evaluate the model by integrating over the energy bins.</span>
<span class="sd">        This can be overloaded to convolve the model with a response, for example</span>


<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_contiguous_energies</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predefined_energies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_integral_flux</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">edges</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_integral_flux</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_background_integral_flux</span><span class="p">(</span><span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">emin</span><span class="p">,</span> <span class="n">emax</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">bin_stack</span>
                <span class="p">]</span>
            <span class="p">)</span>

<div class="viewcode-block" id="SpectrumLike.get_background_model"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.get_background_model">[docs]</a>    <span class="k">def</span> <span class="nf">get_background_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">without_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The background model integrated over the energy bins. Note that it only returns the  model for the</span>
<span class="sd">        currently active channels/measurements</span>

<span class="sd">        :return: array of folded model</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">without_mask</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="p">(</span><span class="n">model</span><span class="p">,)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_background_model</span><span class="p">()</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">model</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_background_model</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">]</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">model</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_background_model</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span>
            <span class="p">)</span>

        <span class="c1"># TODO: should I use the constant here?</span>

        <span class="c1"># return self._nuisance_parameter.value * model</span>

        <span class="k">return</span> <span class="n">model</span></div>

    <span class="k">def</span> <span class="nf">_get_diff_flux_and_integral</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">likelihood_model</span><span class="p">:</span> <span class="n">Model</span><span class="p">,</span> <span class="n">integrate_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;simpson&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">]:</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">integrate_method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;simpson&quot;</span><span class="p">,</span> <span class="s2">&quot;trapz&quot;</span><span class="p">,</span> <span class="s2">&quot;riemann&quot;</span><span class="p">]:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Only simpson and trapz are valid integral_methods.&quot;</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> is using all point sources&quot;</span><span class="p">)</span>

            <span class="n">n_point_sources</span> <span class="o">=</span> <span class="n">likelihood_model</span><span class="o">.</span><span class="n">get_number_of_point_sources</span><span class="p">()</span>

            <span class="c1"># Make a function which will stack all point sources (OGIP do not support spatial dimension)</span>

            <span class="k">def</span> <span class="nf">differential_flux</span><span class="p">(</span><span class="n">energies</span><span class="p">):</span>
                <span class="n">fluxes</span> <span class="o">=</span> <span class="n">likelihood_model</span><span class="o">.</span><span class="n">get_point_source_fluxes</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span> <span class="n">energies</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">,</span> <span class="n">stokes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_stokes</span>
                <span class="p">)</span>

                <span class="c1"># If we have only one point source, this will never be executed</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_point_sources</span><span class="p">):</span>
                    <span class="n">fluxes</span> <span class="o">+=</span> <span class="n">likelihood_model</span><span class="o">.</span><span class="n">get_point_source_fluxes</span><span class="p">(</span>
                        <span class="n">i</span><span class="p">,</span> <span class="n">energies</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">,</span> <span class="n">stokes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_stokes</span>
                    <span class="p">)</span>

                <span class="k">return</span> <span class="n">fluxes</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># This SpectrumLike dataset refers to a specific source</span>

            <span class="c1"># Note that we checked that self._source_name is in the model when the model was set</span>

            <span class="k">try</span><span class="p">:</span>

                <span class="k">def</span> <span class="nf">differential_flux</span><span class="p">(</span><span class="n">energies</span><span class="p">):</span>

                    <span class="k">return</span> <span class="n">likelihood_model</span><span class="o">.</span><span class="n">sources</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_source_name</span><span class="p">](</span>
                        <span class="n">energies</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">,</span> <span class="n">stokes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_stokes</span>
                    <span class="p">)</span>

                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> is using only the point source </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_source_name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>

                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;This SpectumLike plugin has been assigned to source </span><span class="si">%s</span><span class="s2">, &quot;</span>
                    <span class="s2">&quot;which does not exist in the current model&quot;</span>
                    <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_name</span>
                <span class="p">)</span>

                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">()</span>

        <span class="c1"># The following integrates the diffFlux function using Simpson&#39;s rule</span>
        <span class="c1"># This assume that the intervals e1,e2 are all small, which is guaranteed</span>
        <span class="c1"># for any reasonable response matrix, given that e1 and e2 are Monte-Carlo</span>
        <span class="c1"># energies. It also assumes that the function is smooth in the interval</span>
        <span class="c1"># e1 - e2 and twice-differentiable, again reasonable on small intervals for</span>
        <span class="c1"># decent models. It might fail for models with too sharp features, smaller</span>
        <span class="c1"># than the size of the monte carlo interval.</span>

        <span class="k">if</span> <span class="n">integrate_method</span> <span class="o">==</span> <span class="s2">&quot;simpson&quot;</span><span class="p">:</span>

            <span class="c1"># New way with simpson rule.</span>
            <span class="c1"># Make sure to not calculate the model twice for the same energies</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_contiguous_energies</span><span class="p">:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predefined_energies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                    <span class="k">def</span> <span class="nf">integral</span><span class="p">(</span><span class="n">e_edges</span><span class="p">):</span>

                        <span class="c1"># Make sure we do not calculate the flux two times at the same energy</span>
                        <span class="c1"># e_edges = np.append(e1, e2[-1])</span>
                        <span class="n">e_m</span> <span class="o">=</span> <span class="p">(</span><span class="n">e_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">e_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>

                        <span class="n">diff_fluxes_edges</span> <span class="o">=</span> <span class="n">differential_flux</span><span class="p">(</span><span class="n">e_edges</span><span class="p">)</span>
                        <span class="n">diff_fluxes_mid</span> <span class="o">=</span> <span class="n">differential_flux</span><span class="p">(</span><span class="n">e_m</span><span class="p">)</span>

                        <span class="k">return</span> <span class="n">_simps</span><span class="p">(</span>
                            <span class="n">e_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                            <span class="n">e_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                            <span class="n">diff_fluxes_edges</span><span class="p">,</span>
                            <span class="n">diff_fluxes_mid</span><span class="p">,</span>
                        <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="n">e_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_predefined_energies</span><span class="p">)</span>
                    <span class="n">ee1</span> <span class="o">=</span> <span class="n">e_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">ee2</span> <span class="o">=</span> <span class="n">e_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

                    <span class="n">e_m</span> <span class="o">=</span> <span class="p">(</span><span class="n">ee1</span> <span class="o">+</span> <span class="n">ee2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

                    <span class="k">def</span> <span class="nf">integral</span><span class="p">():</span>

                        <span class="n">diff_fluxes_edges</span> <span class="o">=</span> <span class="n">differential_flux</span><span class="p">(</span><span class="n">e_edges</span><span class="p">)</span>
                        <span class="n">diff_fluxes_mid</span> <span class="o">=</span> <span class="n">differential_flux</span><span class="p">(</span><span class="n">e_m</span><span class="p">)</span>

                        <span class="k">return</span> <span class="n">_simps</span><span class="p">(</span>
                            <span class="n">ee1</span><span class="p">,</span> <span class="n">ee2</span><span class="p">,</span> <span class="n">diff_fluxes_edges</span><span class="p">,</span> <span class="n">diff_fluxes_mid</span>
                        <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">def</span> <span class="nf">integral</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
                    <span class="c1"># single energy values given</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="p">(</span><span class="n">e2</span> <span class="o">-</span> <span class="n">e1</span><span class="p">)</span>
                        <span class="o">/</span> <span class="mf">6.0</span>
                        <span class="o">*</span> <span class="p">(</span>
                            <span class="n">differential_flux</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span>
                            <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">differential_flux</span><span class="p">((</span><span class="n">e2</span> <span class="o">+</span> <span class="n">e1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
                            <span class="o">+</span> <span class="n">differential_flux</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="k">elif</span> <span class="n">integrate_method</span> <span class="o">==</span> <span class="s2">&quot;trapz&quot;</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_contiguous_energies</span><span class="p">:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predefined_energies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This is not yet here&quot;</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="n">e_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_predefined_energies</span><span class="p">)</span>
                    <span class="n">ee1</span> <span class="o">=</span> <span class="n">e_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">ee2</span> <span class="o">=</span> <span class="n">e_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

                    <span class="k">def</span> <span class="nf">integral</span><span class="p">():</span>
                        <span class="n">diff_fluxes_edges</span> <span class="o">=</span> <span class="n">differential_flux</span><span class="p">(</span><span class="n">e_edges</span><span class="p">)</span>

                        <span class="k">return</span> <span class="n">_trapz</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">diff_fluxes_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">diff_fluxes_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ee1</span><span class="p">,</span> <span class="n">ee2</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                        <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">def</span> <span class="nf">integral</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
                    <span class="c1"># single energy values given</span>
                    <span class="k">return</span> <span class="n">_trapz</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">differential_flux</span><span class="p">(</span><span class="n">e1</span><span class="p">),</span> <span class="n">differential_flux</span><span class="p">(</span><span class="n">e2</span><span class="p">)]</span>
                        <span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">]),</span>
                    <span class="p">)</span>

        <span class="k">elif</span> <span class="n">integrate_method</span> <span class="o">==</span> <span class="s2">&quot;riemann&quot;</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_contiguous_energies</span><span class="p">:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predefined_energies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                    <span class="k">pass</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="n">e_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_predefined_energies</span><span class="p">)</span>
                    <span class="n">ee1</span> <span class="o">=</span> <span class="n">e_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">ee2</span> <span class="o">=</span> <span class="n">e_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

                    <span class="n">e_m</span> <span class="o">=</span> <span class="p">(</span><span class="n">ee1</span> <span class="o">+</span> <span class="n">ee2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

                    <span class="c1"># energy width</span>
                    <span class="n">de</span> <span class="o">=</span> <span class="n">ee2</span> <span class="o">-</span> <span class="n">ee1</span>

                    <span class="k">def</span> <span class="nf">integral</span><span class="p">():</span>

                        <span class="k">return</span> <span class="n">_rsum</span><span class="p">(</span><span class="n">differential_flux</span><span class="p">(</span><span class="n">e_m</span><span class="p">),</span> <span class="n">de</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">def</span> <span class="nf">integral</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>

                    <span class="k">return</span> <span class="n">differential_flux</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">e1</span> <span class="o">+</span> <span class="n">e2</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">e2</span> <span class="o">-</span> <span class="n">e1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">differential_flux</span><span class="p">,</span> <span class="n">integral</span>

<div class="viewcode-block" id="SpectrumLike.use_effective_area_correction"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.use_effective_area_correction">[docs]</a>    <span class="k">def</span> <span class="nf">use_effective_area_correction</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">min_value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
        <span class="n">max_value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">,</span>
        <span class="n">use_gaussian_prior</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">mu</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Activate the use of the effective area correction, which is a multiplicative factor in front of the model which</span>
<span class="sd">        might be used to mitigate the effect of intercalibration mismatch between different instruments.</span>

<span class="sd">        NOTE: do not use this is you are using only one detector, as the multiplicative constant will be completely</span>
<span class="sd">        degenerate with the normalization of the model.</span>

<span class="sd">        NOTE2: always keep at least one multiplicative constant fixed to one (its default value), when using this</span>
<span class="sd">        with other OGIPLike-type detectors</span>

<span class="sd">        :param min_value: minimum allowed value (default: 0.8, corresponding to a 20% - effect)</span>
<span class="sd">        :param max_value: maximum allowed value (default: 1.2, corresponding to a 20% + effect)</span>
<span class="sd">        :param use_gaussian_prior: use a gaussian prior on the constant</span>
<span class="sd">        :param mu: the center of the gaussian</span>
<span class="sd">        :param sigma: the spread of the gaussian</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s2"> is using effective area correction (between </span><span class="si">{</span><span class="n">min_value</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">max_value</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nuisance_parameter</span><span class="o">.</span><span class="n">free</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nuisance_parameter</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">)</span>

        <span class="c1"># Use a uniform prior by default</span>
        <span class="k">if</span> <span class="n">use_gaussian_prior</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_nuisance_parameter</span><span class="o">.</span><span class="n">prior</span> <span class="o">=</span> <span class="n">Truncated_gaussian</span><span class="p">(</span>
                <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=</span><span class="n">min_value</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="n">max_value</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_nuisance_parameter</span><span class="o">.</span><span class="n">set_uninformative_prior</span><span class="p">(</span><span class="n">Uniform_prior</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpectrumLike.fix_effective_area_correction"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.fix_effective_area_correction">[docs]</a>    <span class="k">def</span> <span class="nf">fix_effective_area_correction</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fix the multiplicative factor (see use_effective_area_correction) to the provided value (default: 1)</span>

<span class="sd">        :param value: new value (default: 1, i.e., no correction)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nuisance_parameter</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nuisance_parameter</span><span class="o">.</span><span class="n">fix</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="SpectrumLike.set_model_integrate_method"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.set_model_integrate_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_model_integrate_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the integrate method for the model integration</span>
<span class="sd">        :param method: (str) which method should be used (simpson or trapz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;simpson&quot;</span><span class="p">,</span> <span class="s2">&quot;trapz&quot;</span><span class="p">,</span> <span class="s2">&quot;riemann&quot;</span><span class="p">]:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Only simpson and trapz are valid intergate methods.&quot;</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_model_integrate_method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s2"> changing model integration method to </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># if like_model already set, upadte the integral function</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_like_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">differential_flux</span><span class="p">,</span> <span class="n">integral</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_diff_flux_and_integral</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_like_model</span><span class="p">,</span> <span class="n">integrate_method</span><span class="o">=</span><span class="n">method</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_integral_flux</span> <span class="o">=</span> <span class="n">integral</span></div>

    <span class="k">def</span> <span class="nf">__set_model_integrate_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_model_integrate_method</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">___set_model_integrate_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__set_model_integrate_method</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_model_integrate_method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_integrate_method</span>

    <span class="k">def</span> <span class="nf">___get_model_integrate_method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__set_model_integrate_method</span><span class="p">()</span>

    <span class="n">model_integrate_method</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span>
        <span class="n">___get_model_integrate_method</span><span class="p">,</span>
        <span class="n">___set_model_integrate_method</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The method used to integrate the model across the response matrix &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>

<div class="viewcode-block" id="SpectrumLike.set_background_integrate_method"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.set_background_integrate_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_background_integrate_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the integrate method for the background integration</span>
<span class="sd">        :param method: (str) which method should be used (simpson or trapz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;simpson&quot;</span><span class="p">,</span> <span class="s2">&quot;trapz&quot;</span><span class="p">,</span> <span class="s2">&quot;riemann&quot;</span><span class="p">]:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Only simpson and trapz are valid intergate methods.&quot;</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_background_integrate_method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s2"> changing background integration method to </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># if background_plugin is set, update the integral function</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">differential_flux</span><span class="p">,</span> <span class="n">integral</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_diff_flux_and_integral</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span><span class="o">.</span><span class="n">likelihood_model</span><span class="p">,</span>
                <span class="n">integrate_method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_background_integral_flux</span> <span class="o">=</span> <span class="n">integral</span></div>

    <span class="k">def</span> <span class="nf">__set_background_integrate_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_background_integrate_method</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">___set_background_integrate_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__set_background_integrate_method</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_background_integrate_method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_integrate_method</span>

    <span class="k">def</span> <span class="nf">___get_background_integrate_method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__set_background_integrate_method</span><span class="p">()</span>

    <span class="n">background_integrate_method</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span>
        <span class="n">___get_background_integrate_method</span><span class="p">,</span>
        <span class="n">___set_background_integrate_method</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The method used to integrate the_background across the response matrix &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The channel mask</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tstart</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tstart</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tstop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tstop</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">expected_model_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_model</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nuisance_parameter</span><span class="o">.</span><span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">observed_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :return: the observed counts</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_counts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">observed_count_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :return: the observed counts errors</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cnt_err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;self._observation_noise_model = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observation_noise_model</span>
        <span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;self._background_noise_model = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observation_noise_model</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>

            <span class="n">cnt_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_counts</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># if self._background_noise_model is None:</span>
            <span class="n">cnt_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_count_errors</span>
            <span class="c1"># elif self._background_noise_model is &quot;gaussian&quot;:</span>
            <span class="c1">#    cnt_err = self._observed_count_errors</span>
            <span class="c1"># calculate all the correct quantites</span>

        <span class="k">return</span> <span class="n">cnt_err</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">background_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :return: the observed background counts</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">background_counts</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observation_noise_model</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>

                <span class="n">background_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_counts</span>

                <span class="c1"># Gehrels weighting, a little bit better approximation when statistic is low</span>
                <span class="c1"># (and inconsequential when statistic is high)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;ideal&quot;</span><span class="p">:</span>

                <span class="n">background_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_background_counts</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>

                <span class="n">background_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_counts</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="n">background_counts</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;modeled&quot;</span><span class="p">:</span>

                <span class="c1"># get the background counts from the background</span>
                <span class="c1"># plugin.. NOT SCALED</span>

                <span class="n">background_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_background_model</span><span class="p">(</span><span class="n">without_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;This is a bug&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># gaussian observation</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Observed counts</span>
                <span class="n">background_counts</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>

                <span class="n">background_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_counts</span>
                <span class="c1"># calculate all the correct quantites</span>

        <span class="k">return</span> <span class="n">background_counts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">background_count_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :return: the observed background count errors</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">background_errors</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observation_noise_model</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>

                <span class="c1"># Gehrels weighting, a little bit better approximation when statistic is low</span>
                <span class="c1"># (and inconsequential when statistic is high)</span>

                <span class="n">background_errors</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_counts</span> <span class="o">+</span> <span class="mf">0.75</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;ideal&quot;</span><span class="p">:</span>

                <span class="n">background_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_background_counts</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>

                <span class="n">background_errors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_back_count_errors</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="k">return</span> <span class="kc">None</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;modeled&quot;</span><span class="p">:</span>

                <span class="c1"># get the background count error from the background</span>
                <span class="c1"># plugin.. NOT SCALED</span>

                <span class="n">background_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_background_model</span><span class="p">(</span><span class="n">without_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;This is a bug&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">background_errors</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>

                <span class="n">background_errors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_back_count_errors</span>

        <span class="k">return</span> <span class="n">background_errors</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The source rate of the model. If there is background or a background background plugin present,</span>
<span class="sd">        the source is background subtracted, but only for visual purposes. If no background is present,</span>
<span class="sd">        then, this is just the observed rate.</span>

<span class="sd">        :return: the source rate</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>

            <span class="c1"># since we compare to the model rate... background subtract but with proper propagation</span>
            <span class="n">src_rate</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">observed_counts</span>
                <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">exposure</span>
                <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">scale_factor</span>
                <span class="o">-</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">background_counts</span>
                    <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span>
                    <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_scale_factor</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># since we compare to the model rate... background subtract but with proper propagation</span>
            <span class="n">src_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_counts</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">exposure</span>

        <span class="k">return</span> <span class="n">src_rate</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_rate_error</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The source rate error of the model. If there is background or a background background plugin present,</span>
<span class="sd">        the source is background subtracted, but only for visual purposes. If no background is present,</span>
<span class="sd">        then, this is just the observed rate.</span>

<span class="sd">        :return: the source rate error</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>

            <span class="n">src_rate_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">observed_count_errors</span>
                    <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">exposure</span>
                    <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">scale_factor</span>
                <span class="p">)</span>
                <span class="o">**</span> <span class="mi">2</span>
                <span class="o">+</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">background_count_errors</span>
                    <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span>
                    <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_scale_factor</span>
                <span class="p">)</span>
                <span class="o">**</span> <span class="mi">2</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">src_rate_err</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">observed_count_errors</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">exposure</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">src_rate_err</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">quality</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quality</span><span class="p">:</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">quality</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">energy_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Energy boundaries of channels currently in use (rebinned, if a rebinner is active)</span>

<span class="sd">        :return: (energy_min, energy_max)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>

        <span class="n">energy_min</span><span class="p">,</span> <span class="n">energy_max</span> <span class="o">=</span> <span class="n">energies</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">energies</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Get the rebinned chans. NOTE: these are already masked</span>

            <span class="n">energy_min</span><span class="p">,</span> <span class="n">energy_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span><span class="o">.</span><span class="n">get_new_start_and_stop</span><span class="p">(</span>
                <span class="n">energy_min</span><span class="p">,</span> <span class="n">energy_max</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># Apply the mask</span>
            <span class="n">energy_min</span> <span class="o">=</span> <span class="n">energy_min</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">]</span>
            <span class="n">energy_max</span> <span class="o">=</span> <span class="n">energy_max</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">energy_min</span><span class="p">,</span> <span class="n">energy_max</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_data_points</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span><span class="o">.</span><span class="n">n_bins</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">significance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: the significance of the data over background</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sig_obj</span> <span class="o">=</span> <span class="n">Significance</span><span class="p">(</span>
            <span class="n">Non</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">total_count</span><span class="p">,</span>
            <span class="n">Noff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">total_count</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_total_scale_factor</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">is_poisson</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">is_poisson</span>
            <span class="p">):</span>

                <span class="c1"># use simple li &amp; ma</span>
                <span class="n">significance</span> <span class="o">=</span> <span class="n">sig_obj</span><span class="o">.</span><span class="n">li_and_ma</span><span class="p">()</span>

            <span class="k">elif</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">is_poisson</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">is_poisson</span>
            <span class="p">):</span>

                <span class="n">significance</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">sig_obj</span><span class="o">.</span><span class="n">li_and_ma_equivalent_for_gaussian_background</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">total_count_error</span>
                    <span class="p">)</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;We haven&#39;t put in other significances yet&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Significance with no background is not yet computed accurately&quot;</span>
            <span class="p">)</span>
            <span class="n">significance</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">significance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">significance_per_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: the significance of the data over background per channel</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>

            <span class="n">sig_obj</span> <span class="o">=</span> <span class="n">Significance</span><span class="p">(</span>
                <span class="n">Non</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_observed_counts</span><span class="p">,</span>
                <span class="n">Noff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_background_counts</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_total_scale_factor</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">is_poisson</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">is_poisson</span>
            <span class="p">):</span>

                <span class="c1"># use simple li &amp; ma</span>
                <span class="n">significance</span> <span class="o">=</span> <span class="n">sig_obj</span><span class="o">.</span><span class="n">li_and_ma</span><span class="p">()</span>

            <span class="k">elif</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">is_poisson</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">is_poisson</span>
            <span class="p">):</span>

                <span class="n">significance</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">sig_obj</span><span class="o">.</span><span class="n">li_and_ma_equivalent_for_gaussian_background</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_current_back_count_errors</span>
                    <span class="p">)</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;We haven&#39;t put in other significances yet&quot;</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">significance</span>

<div class="viewcode-block" id="SpectrumLike.write_pha"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.write_pha">[docs]</a>    <span class="k">def</span> <span class="nf">write_pha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;this is in progress&quot;</span><span class="p">)</span></div>

        <span class="c1"># we just need to make a diagonal response and then follow the example in dispersion like</span>

<div class="viewcode-block" id="SpectrumLike.view_count_spectrum"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.view_count_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">view_count_spectrum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">plot_errors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_bad_channels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_warn_channels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">significance_level</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_background</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        View the count and background spectrum. Useful to check energy selections.</span>
<span class="sd">        :param plot_errors: plot errors on the counts</span>
<span class="sd">        :param show_bad_channels: (bool) show which channels are bad in the native PHA quality</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;There are no active channels selected to plot!&quot;</span><span class="p">)</span>

        <span class="c1"># adding the rebinner: j. michael.</span>

        <span class="c1"># In the future read colors from config file</span>

        <span class="c1"># First plot the counts</span>

        <span class="c1"># find out the type of observation</span>

        <span class="n">modeled_label</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observation_noise_model</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>

            <span class="c1"># Observed counts</span>
            <span class="n">observed_counts</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_observed_counts</span><span class="p">)</span>

            <span class="n">cnt_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">observed_counts</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>

                <span class="n">background_counts</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_background_counts</span><span class="p">)</span>

                <span class="n">background_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">background_counts</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;ideal&quot;</span><span class="p">:</span>

                <span class="n">background_counts</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_current_scaled_background_counts</span>
                <span class="p">)</span>

                <span class="n">background_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">background_counts</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>

                <span class="n">background_counts</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_background_counts</span><span class="p">)</span>

                <span class="n">background_errors</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_back_count_errors</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                    <span class="n">observed_counts</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_observed_counts</span><span class="p">)</span>
                    <span class="n">background_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">observed_counts</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">background_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">observed_counts</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;This is a bug&quot;</span><span class="p">)</span>

                    <span class="c1"># we will show the modeled counts</span>

                    <span class="n">background_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_background_model</span><span class="p">()</span>
                    <span class="n">background_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">background_counts</span><span class="p">)</span>

                    <span class="n">modeled_label</span> <span class="o">=</span> <span class="s2">&quot;Modeled &quot;</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;modeled&quot;</span><span class="p">:</span>

                <span class="n">background_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_background_model</span><span class="p">()</span>
                <span class="n">background_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">background_counts</span><span class="p">)</span>

                <span class="n">modeled_label</span> <span class="o">=</span> <span class="s2">&quot;Modeled &quot;</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;This is a bug&quot;</span><span class="p">)</span>

                <span class="c1"># convert to rates, ugly, yes</span>

            <span class="c1">#            background_counts /= self._background_exposure</span>
            <span class="c1">#            background_errors /= self._background_exposure</span>

            <span class="n">background_rate</span> <span class="o">=</span> <span class="n">background_counts</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span>
            <span class="n">background_rate_errors</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">background_errors</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span>
            <span class="p">)</span>

        <span class="c1"># Gaussian observation</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">observed_counts</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_observed_counts</span><span class="p">)</span>

                <span class="n">background_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="n">observed_counts</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span>
                <span class="p">)</span>
                <span class="n">background_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="n">observed_counts</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span>
                <span class="p">)</span>

                <span class="n">background_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">observed_counts</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

                <span class="n">background_rate_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">observed_counts</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

                <span class="n">cnt_err</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_observed_count_errors</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>
                <span class="n">observed_counts</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_observed_counts</span><span class="p">)</span>

                <span class="n">background_counts</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_background_counts</span><span class="p">)</span>

                <span class="n">background_errors</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_back_count_errors</span><span class="p">)</span>

                <span class="n">background_rate</span> <span class="o">=</span> <span class="n">background_counts</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span>

                <span class="n">background_rate_errors</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">background_errors</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span>
                <span class="p">)</span>

                <span class="n">cnt_err</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_observed_count_errors</span><span class="p">)</span>

        <span class="c1"># convert to rates, ugly, yes</span>

        <span class="n">observed_rates</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">observed_counts</span>
            <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">exposure</span>
            <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">scale_factor</span>
        <span class="p">)</span>
        <span class="n">rate_err</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">cnt_err</span>
            <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">exposure</span>
            <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">scale_factor</span>
        <span class="p">)</span>
        <span class="c1"># observed_counts /= self._observed_spectrum.exposure</span>
        <span class="c1">#        cnt_err /= self._observed_spectrum.exposure</span>

        <span class="k">if</span> <span class="n">scale_background</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_background</span><span class="p">:</span>

            <span class="n">background_rate</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_scale_factor</span>
            <span class="n">background_rate_errors</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_scale_factor</span>

            <span class="n">background_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Scaled </span><span class="si">{</span><span class="n">modeled_label</span><span class="si">}</span><span class="s2">Background&quot;</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">background_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">modeled_label</span><span class="si">}</span><span class="s2">Background&quot;</span>

        <span class="c1"># Make the plots</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="c1"># Get the energy boundaries</span>

        <span class="n">energy_min</span><span class="p">,</span> <span class="n">energy_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_boundaries</span>

        <span class="n">energy_width</span> <span class="o">=</span> <span class="n">energy_max</span> <span class="o">-</span> <span class="n">energy_min</span>

        <span class="c1"># plot counts and background for the currently selected data</span>

        <span class="n">channel_plot</span><span class="p">(</span>
            <span class="n">ax</span><span class="p">,</span>
            <span class="n">energy_min</span><span class="p">,</span>
            <span class="n">energy_max</span><span class="p">,</span>
            <span class="n">observed_rates</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">threeML_config</span><span class="p">[</span><span class="s2">&quot;plugins&quot;</span><span class="p">][</span><span class="s2">&quot;ogip&quot;</span><span class="p">][</span><span class="s2">&quot;data_plot&quot;</span><span class="p">][</span>
                <span class="s2">&quot;counts_color&quot;</span>
            <span class="p">],</span>
            <span class="n">lw</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Total&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">background_rate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_background</span><span class="p">:</span>

            <span class="n">channel_plot</span><span class="p">(</span>
                <span class="n">ax</span><span class="p">,</span>
                <span class="n">energy_min</span><span class="p">,</span>
                <span class="n">energy_max</span><span class="p">,</span>
                <span class="n">background_rate</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="n">threeML_config</span><span class="p">[</span><span class="s2">&quot;plugins&quot;</span><span class="p">][</span><span class="s2">&quot;ogip&quot;</span><span class="p">][</span><span class="s2">&quot;data_plot&quot;</span><span class="p">][</span>
                    <span class="s2">&quot;background_color&quot;</span>
                <span class="p">],</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="n">background_label</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">mean_chan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">energy_min</span><span class="p">,</span> <span class="n">energy_max</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># if asked, plot the errors</span>

        <span class="k">if</span> <span class="n">plot_errors</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span>
                <span class="n">mean_chan</span><span class="p">,</span>
                <span class="n">observed_rates</span> <span class="o">/</span> <span class="n">energy_width</span><span class="p">,</span>
                <span class="n">yerr</span><span class="o">=</span><span class="n">rate_err</span> <span class="o">/</span> <span class="n">energy_width</span><span class="p">,</span>
                <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="c1"># markersize=3,</span>
                <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="n">elinewidth</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                <span class="n">capsize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="c1"># label=data._name,</span>
                <span class="n">color</span><span class="o">=</span><span class="n">threeML_config</span><span class="p">[</span><span class="s2">&quot;plugins&quot;</span><span class="p">][</span><span class="s2">&quot;ogip&quot;</span><span class="p">][</span><span class="s2">&quot;data_plot&quot;</span><span class="p">][</span>
                    <span class="s2">&quot;counts_color&quot;</span>
                <span class="p">],</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span>
                    <span class="n">mean_chan</span><span class="p">,</span>
                    <span class="n">background_rate</span> <span class="o">/</span> <span class="n">energy_width</span><span class="p">,</span>
                    <span class="n">yerr</span><span class="o">=</span><span class="n">background_rate_errors</span> <span class="o">/</span> <span class="n">energy_width</span><span class="p">,</span>
                    <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                    <span class="c1"># markersize=3,</span>
                    <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                    <span class="n">elinewidth</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                    <span class="n">capsize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="c1"># label=data._name,</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">threeML_config</span><span class="p">[</span><span class="s2">&quot;plugins&quot;</span><span class="p">][</span><span class="s2">&quot;ogip&quot;</span><span class="p">][</span><span class="s2">&quot;data_plot&quot;</span><span class="p">][</span>
                        <span class="s2">&quot;background_color&quot;</span>
                    <span class="p">],</span>
                <span class="p">)</span>

        <span class="c1"># Now plot and fade the non-used channels</span>
        <span class="n">non_used_mask</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>

        <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>  <span class="c1"># non_used_mask.sum() &gt; 0:</span>

            <span class="c1"># Get un-rebinned versions of all arrays, so we can directly apply the mask</span>
            <span class="n">energy_min_unrebinned</span><span class="p">,</span> <span class="n">energy_max_unrebinned</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">starts</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">stops</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">energy_width_unrebinned</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">energy_max_unrebinned</span> <span class="o">-</span> <span class="n">energy_min_unrebinned</span>
            <span class="p">)</span>
            <span class="n">observed_rate_unrebinned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_counts</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span>

            <span class="n">observed_rate_unrebinned_err</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_counts</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">non_used_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="n">channel_plot</span><span class="p">(</span>
                    <span class="n">ax</span><span class="p">,</span>
                    <span class="n">energy_min_unrebinned</span><span class="p">[</span><span class="n">non_used_mask</span><span class="p">],</span>
                    <span class="n">energy_max_unrebinned</span><span class="p">[</span><span class="n">non_used_mask</span><span class="p">],</span>
                    <span class="n">observed_rate_unrebinned</span><span class="p">[</span><span class="n">non_used_mask</span><span class="p">],</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">threeML_config</span><span class="o">.</span><span class="n">plugins</span><span class="o">.</span><span class="n">ogip</span><span class="o">.</span><span class="n">data_plot</span><span class="o">.</span><span class="n">counts_color</span><span class="p">,</span>
                    <span class="n">lw</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;modeled&quot;</span><span class="p">:</span>

                    <span class="n">background_rate_unrebinned</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">get_background_model</span><span class="p">(</span><span class="n">without_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span>
                    <span class="p">)</span>
                    <span class="n">background_rate_unrebinned_err</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_background_model</span><span class="p">(</span><span class="n">without_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                        <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span>
                    <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="n">background_rate_unrebinned</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_background_counts</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">background_exposure</span>
                    <span class="p">)</span>

                    <span class="n">background_rate_unrebinned_err</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_counts</span><span class="p">)</span>
                        <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">background_exposure</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">non_used_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                    <span class="n">channel_plot</span><span class="p">(</span>
                        <span class="n">ax</span><span class="p">,</span>
                        <span class="n">energy_min_unrebinned</span><span class="p">[</span><span class="n">non_used_mask</span><span class="p">],</span>
                        <span class="n">energy_max_unrebinned</span><span class="p">[</span><span class="n">non_used_mask</span><span class="p">],</span>
                        <span class="n">background_rate_unrebinned</span><span class="p">[</span><span class="n">non_used_mask</span><span class="p">],</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">threeML_config</span><span class="o">.</span><span class="n">plugins</span><span class="o">.</span><span class="n">ogip</span><span class="o">.</span><span class="n">data_plot</span><span class="o">.</span><span class="n">background_color</span><span class="p">,</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="n">background_rate_unrebinned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span>
                    <span class="n">observed_rate_unrebinned</span>
                <span class="p">)</span>
                <span class="n">background_rate_unrebinned_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span>
                    <span class="n">observed_rate_unrebinned_err</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">plot_errors</span><span class="p">:</span>
                <span class="n">mean_chan_unrebinned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">energy_min_unrebinned</span><span class="p">,</span> <span class="n">energy_max_unrebinned</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>

                <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span>
                    <span class="n">mean_chan_unrebinned</span><span class="p">[</span><span class="n">non_used_mask</span><span class="p">],</span>
                    <span class="n">observed_rate_unrebinned</span><span class="p">[</span><span class="n">non_used_mask</span><span class="p">]</span>
                    <span class="o">/</span> <span class="n">energy_width_unrebinned</span><span class="p">[</span><span class="n">non_used_mask</span><span class="p">],</span>
                    <span class="n">yerr</span><span class="o">=</span><span class="n">observed_rate_unrebinned_err</span><span class="p">[</span><span class="n">non_used_mask</span><span class="p">]</span>
                    <span class="o">/</span> <span class="n">energy_width_unrebinned</span><span class="p">[</span><span class="n">non_used_mask</span><span class="p">],</span>
                    <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                    <span class="c1"># markersize=3,</span>
                    <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                    <span class="n">elinewidth</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                    <span class="n">capsize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="c1"># label=data._name,</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">threeML_config</span><span class="o">.</span><span class="n">plugins</span><span class="o">.</span><span class="n">ogip</span><span class="o">.</span><span class="n">data_plot</span><span class="o">.</span><span class="n">counts_color</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span>
                        <span class="n">mean_chan_unrebinned</span><span class="p">[</span><span class="n">non_used_mask</span><span class="p">],</span>
                        <span class="n">background_rate_unrebinned</span><span class="p">[</span><span class="n">non_used_mask</span><span class="p">]</span>
                        <span class="o">/</span> <span class="n">energy_width_unrebinned</span><span class="p">[</span><span class="n">non_used_mask</span><span class="p">],</span>
                        <span class="n">yerr</span><span class="o">=</span><span class="n">background_rate_unrebinned_err</span><span class="p">[</span><span class="n">non_used_mask</span><span class="p">]</span>
                        <span class="o">/</span> <span class="n">energy_width_unrebinned</span><span class="p">[</span><span class="n">non_used_mask</span><span class="p">],</span>
                        <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                        <span class="c1"># markersize=3,</span>
                        <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                        <span class="n">elinewidth</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                        <span class="n">capsize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="c1"># label=data._name,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">threeML_config</span><span class="o">.</span><span class="n">plugins</span><span class="o">.</span><span class="n">ogip</span><span class="o">.</span><span class="n">data_plot</span><span class="o">.</span><span class="n">background_color</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="c1"># make some nice top and bottom plot ranges</span>

            <span class="c1"># tmp_bkg = background_rate_unrebinned / energy_width_unrebinned</span>
            <span class="c1"># tmp_bkg = tmp_bkg[np.isfinite(tmp_bkg)]</span>

            <span class="c1"># tmp_obs = observed_rate_unrebinned / energy_width_unrebinned</span>
            <span class="c1"># tmp_obs = tmp_obs[np.isfinite(tmp_obs)]</span>

            <span class="n">tmp_bkg</span> <span class="o">=</span> <span class="n">background_rate</span> <span class="o">/</span> <span class="n">energy_width</span>
            <span class="n">tmp_bkg</span> <span class="o">=</span> <span class="n">tmp_bkg</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">tmp_bkg</span><span class="p">)]</span>

            <span class="n">tmp_obs</span> <span class="o">=</span> <span class="n">observed_rates</span> <span class="o">/</span> <span class="n">energy_width</span>
            <span class="n">tmp_obs</span> <span class="o">=</span> <span class="n">tmp_obs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">tmp_obs</span><span class="p">)]</span>

            <span class="n">top</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">tmp_bkg</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">tmp_obs</span><span class="p">)])</span> <span class="o">*</span> <span class="mf">1.5</span>

            <span class="n">bottom</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">min</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="nb">min</span><span class="p">(</span><span class="n">tmp_bkg</span><span class="p">),</span>
                        <span class="nb">min</span><span class="p">(</span><span class="n">tmp_obs</span><span class="p">),</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="o">*</span> <span class="mf">0.8</span>
            <span class="p">)</span>

            <span class="c1"># plot the deselected regions</span>

            <span class="n">disjoint_patch_plot</span><span class="p">(</span>
                <span class="n">ax</span><span class="p">,</span>
                <span class="n">energy_min_unrebinned</span><span class="p">,</span>
                <span class="n">energy_max_unrebinned</span><span class="p">,</span>
                <span class="n">top</span><span class="p">,</span>
                <span class="n">bottom</span><span class="p">,</span>
                <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="n">threeML_config</span><span class="o">.</span><span class="n">plugins</span><span class="o">.</span><span class="n">ogip</span><span class="o">.</span><span class="n">data_plot</span><span class="o">.</span><span class="n">masked_channels_color</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># plot the bad quality channels if requested</span>

            <span class="k">if</span> <span class="n">show_bad_channels</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">quality</span><span class="o">.</span><span class="n">bad</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;bad channels shown in red hatching</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">disjoint_patch_plot</span><span class="p">(</span>
                    <span class="n">ax</span><span class="p">,</span>
                    <span class="n">energy_min_unrebinned</span><span class="p">,</span>
                    <span class="n">energy_max_unrebinned</span><span class="p">,</span>
                    <span class="n">top</span><span class="p">,</span>
                    <span class="n">bottom</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">quality</span><span class="o">.</span><span class="n">bad</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
                    <span class="n">edgecolor</span><span class="o">=</span><span class="n">threeML_config</span><span class="o">.</span><span class="n">plugins</span><span class="o">.</span><span class="n">ogip</span><span class="o">.</span><span class="n">data_plot</span><span class="o">.</span><span class="n">bad_channels_color</span><span class="p">,</span>
                    <span class="n">hatch</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">show_warn_channels</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">quality</span><span class="o">.</span><span class="n">warn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;warned channels shown in purple hatching</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">disjoint_patch_plot</span><span class="p">(</span>
                    <span class="n">ax</span><span class="p">,</span>
                    <span class="n">energy_min_unrebinned</span><span class="p">,</span>
                    <span class="n">energy_max_unrebinned</span><span class="p">,</span>
                    <span class="n">top</span><span class="p">,</span>
                    <span class="n">bottom</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">quality</span><span class="o">.</span><span class="n">bad</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
                    <span class="n">edgecolor</span><span class="o">=</span><span class="n">threeML_config</span><span class="o">.</span><span class="n">plugins</span><span class="o">.</span><span class="n">ogip</span><span class="o">.</span><span class="n">data_plot</span><span class="o">.</span><span class="n">warn_channels_color</span><span class="p">,</span>
                    <span class="n">hatch</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">significance_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;channels below the significance threshold shown in red</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>

                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                    <span class="n">significance_mask</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">significance_per_channel</span> <span class="o">&lt;</span> <span class="n">significance_level</span>
                    <span class="p">)</span>

                <span class="n">disjoint_patch_plot</span><span class="p">(</span>
                    <span class="n">ax</span><span class="p">,</span>
                    <span class="n">energy_min_unrebinned</span><span class="p">,</span>
                    <span class="n">energy_max_unrebinned</span><span class="p">,</span>
                    <span class="n">top</span><span class="p">,</span>
                    <span class="n">bottom</span><span class="p">,</span>
                    <span class="n">significance_mask</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Energy (keV)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Rate (counts s$^{-1}$ keV$^{-1}$)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span>
            <span class="n">left</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">absolute_start</span><span class="p">,</span>
            <span class="n">right</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">absolute_stop</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span></div>

    <span class="k">def</span> <span class="nf">_output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; pd.Series</span>

        <span class="n">obs</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;n. channels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">n_channels</span>

        <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;total rate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">total_rate</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">is_poisson</span><span class="p">:</span>
            <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;total rate error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">total_rate_error</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;total bkg. rate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">total_rate</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">is_poisson</span><span class="p">:</span>
                <span class="n">obs</span><span class="p">[</span>
                    <span class="s2">&quot;total bkg. rate error&quot;</span>
                <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">total_rate_error</span>
            <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;bkg. exposure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">background_exposure</span>
            <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;bkg. is poisson&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span><span class="o">.</span><span class="n">is_poisson</span>

        <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;exposure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span>
        <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;is poisson&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">is_poisson</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;background&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;modeled from plugin </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span><span class="o">.</span><span class="n">name</span>
            <span class="p">)</span>
            <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;significance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">significance</span>
            <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;src/bkg area ratio&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area_ratio</span>
            <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;src/bkg exposure ratio&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exposure_ratio</span>
            <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;src/bkg scale factor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_scale_factor</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;background&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;profiled&quot;</span>
            <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;significance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">significance</span>
            <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;src/bkg area ratio&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area_ratio</span>
            <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;src/bkg exposure ratio&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exposure_ratio</span>
            <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;src/bkg scale factor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_scale_factor</span>

        <span class="c1"># obs[&#39;response&#39;] = self._observed_spectrum.response_file</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">obs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

<div class="viewcode-block" id="SpectrumLike.get_number_of_data_points"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.get_number_of_data_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_number_of_data_points</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns the number of active data bins</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># the sum of the mask should be the number of data bins in use</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>

<div class="viewcode-block" id="SpectrumLike.display"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.display">[docs]</a>    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">display</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_output</span><span class="p">()</span><span class="o">.</span><span class="n">to_frame</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output</span><span class="p">()</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_construct_counts_arrays</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">min_rate</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">ratio_residuals</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">total_counts</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Build new arrays before or after a fit of rebinned data/model</span>
<span class="sd">        values. We keep this seperated from the plotting code because</span>
<span class="sd">        it is cleaner and allows us to extract these quantites independently</span>

<span class="sd">        :param min_rate:</span>
<span class="sd">        :param ratio_residuals:</span>
<span class="sd">        :param total_counts: Should this construct the total counts as &quot;data&quot;. If not, the &quot;data counts&quot; are</span>
<span class="sd">        observed-background and the model counts are only source counts. Otherwise &quot;data counts&quot; are observed</span>
<span class="sd">        and model counts are source+background</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># energy_min, energy_max = self._rsp.ebounds[:-1], self._rsp.ebounds[1:]</span>

        <span class="n">energy_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">energy_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="n">chan_width</span> <span class="o">=</span> <span class="n">energy_max</span> <span class="o">-</span> <span class="n">energy_min</span>

        <span class="c1"># Source model</span>
        <span class="n">expected_model_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_model_rate</span>

        <span class="c1"># Observed rate</span>
        <span class="n">observed_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_counts</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">exposure</span>
        <span class="n">observed_rate_err</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">observed_count_errors</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">exposure</span>
        <span class="p">)</span>

        <span class="c1"># Background rate</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_background_plugin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="n">background_rate</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">background_counts</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span>
            <span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area_ratio</span>
            <span class="n">background_rate_err</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">background_count_errors</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_exposure</span>
            <span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area_ratio</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">background_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">observed_rate</span><span class="p">))</span>
            <span class="n">background_rate_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">observed_rate</span><span class="p">))</span>

        <span class="c1"># Create a rebinner if either a min_rate has been given, or if the current data set has no rebinned on its own</span>
        <span class="c1"># rebin on expected model rate</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">min_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">NO_REBIN</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>

            <span class="n">this_rebinner</span> <span class="o">=</span> <span class="n">Rebinner</span><span class="p">(</span><span class="n">expected_model_rate</span><span class="p">,</span> <span class="n">min_rate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># Use the rebinner already in the data</span>
            <span class="n">this_rebinner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebinner</span>

        <span class="c1"># get the rebinned counts</span>
        <span class="p">(</span>
            <span class="n">new_observed_rate</span><span class="p">,</span>
            <span class="n">new_model_rate</span><span class="p">,</span>
            <span class="n">new_background_rate</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">this_rebinner</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span>
            <span class="n">observed_rate</span><span class="p">,</span> <span class="n">expected_model_rate</span><span class="p">,</span> <span class="n">background_rate</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="n">new_observed_rate_err</span><span class="p">,)</span> <span class="o">=</span> <span class="n">this_rebinner</span><span class="o">.</span><span class="n">rebin_errors</span><span class="p">(</span><span class="n">observed_rate_err</span><span class="p">)</span>
        <span class="p">(</span><span class="n">new_background_rate_err</span><span class="p">,)</span> <span class="o">=</span> <span class="n">this_rebinner</span><span class="o">.</span><span class="n">rebin_errors</span><span class="p">(</span>
            <span class="n">background_rate_err</span>
        <span class="p">)</span>

        <span class="c1"># adjust channels</span>
        <span class="n">new_energy_min</span><span class="p">,</span> <span class="n">new_energy_max</span> <span class="o">=</span> <span class="n">this_rebinner</span><span class="o">.</span><span class="n">get_new_start_and_stop</span><span class="p">(</span>
            <span class="n">energy_min</span><span class="p">,</span> <span class="n">energy_max</span>
        <span class="p">)</span>
        <span class="n">new_chan_width</span> <span class="o">=</span> <span class="n">new_energy_max</span> <span class="o">-</span> <span class="n">new_energy_min</span>

        <span class="c1"># mean_energy = np.mean([new_energy_min, new_energy_max], axis=0)</span>

        <span class="c1"># For each bin find the weighted average of the channel center</span>
        <span class="n">mean_energy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">delta_energy</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[]]</span>
        <span class="n">mean_energy_unrebinned</span> <span class="o">=</span> <span class="p">(</span><span class="n">energy_max</span> <span class="o">+</span> <span class="n">energy_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="k">for</span> <span class="n">e_min</span><span class="p">,</span> <span class="n">e_max</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_energy_min</span><span class="p">,</span> <span class="n">new_energy_max</span><span class="p">):</span>

            <span class="c1"># Find all channels in this rebinned bin</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">mean_energy_unrebinned</span> <span class="o">&gt;=</span> <span class="n">e_min</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span>
                <span class="n">mean_energy_unrebinned</span> <span class="o">&lt;=</span> <span class="n">e_max</span>
            <span class="p">)</span>

            <span class="c1"># Find the rates for these channels</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">observed_rate</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">min_rate</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># All empty, cannot weight</span>
                <span class="n">this_mean_energy</span> <span class="o">=</span> <span class="p">(</span><span class="n">e_min</span> <span class="o">+</span> <span class="n">e_max</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># negative src rates cause the energy mean to</span>
                <span class="c1"># go outside of the bounds. So we fix negative rates to</span>
                <span class="c1"># zero when computing the mean</span>

                <span class="n">idx_negative</span> <span class="o">=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">0.0</span>

                <span class="n">r</span><span class="p">[</span><span class="n">idx_negative</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

                <span class="c1"># Do the weighted average of the mean energies</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

                <span class="n">this_mean_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span>
                    <span class="n">mean_energy_unrebinned</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span>
                <span class="p">)</span>

            <span class="c1"># Compute &quot;errors&quot; for X (which aren&#39;t really errors, just to mark the size of the bin)</span>

            <span class="n">delta_energy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_mean_energy</span> <span class="o">-</span> <span class="n">e_min</span><span class="p">)</span>
            <span class="n">delta_energy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e_max</span> <span class="o">-</span> <span class="n">this_mean_energy</span><span class="p">)</span>
            <span class="n">mean_energy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_mean_energy</span><span class="p">)</span>

        <span class="c1"># Residuals</span>

        <span class="c1"># we need to get the rebinned counts</span>
        <span class="p">(</span><span class="n">rebinned_observed_counts</span><span class="p">,)</span> <span class="o">=</span> <span class="n">this_rebinner</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_counts</span><span class="p">)</span>

        <span class="p">(</span><span class="n">rebinned_observed_count_errors</span><span class="p">,)</span> <span class="o">=</span> <span class="n">this_rebinner</span><span class="o">.</span><span class="n">rebin_errors</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">observed_count_errors</span>
        <span class="p">)</span>

        <span class="c1"># the rebinned counts expected from the model</span>
        <span class="n">rebinned_model_counts</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">new_model_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observed_spectrum</span><span class="o">.</span><span class="n">exposure</span>
        <span class="p">)</span>

        <span class="c1"># and also the rebinned background</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># self._background_noise_model == &quot;modeled&quot;:</span>

                <span class="p">(</span><span class="n">rebinned_background_counts</span><span class="p">,)</span> <span class="o">=</span> <span class="n">this_rebinner</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_background_model</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="p">(</span><span class="n">rebinned_background_errors</span><span class="p">,)</span> <span class="o">=</span> <span class="n">this_rebinner</span><span class="o">.</span><span class="n">rebin_errors</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_background_model</span><span class="p">())</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="p">(</span><span class="n">rebinned_background_counts</span><span class="p">,)</span> <span class="o">=</span> <span class="n">this_rebinner</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">background_counts</span>
                <span class="p">)</span>
                <span class="p">(</span><span class="n">rebinned_background_errors</span><span class="p">,)</span> <span class="o">=</span> <span class="n">this_rebinner</span><span class="o">.</span><span class="n">rebin_errors</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">background_count_errors</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">rebinned_background_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">rebinned_observed_counts</span><span class="p">)</span>

        <span class="n">significance_calc</span> <span class="o">=</span> <span class="n">Significance</span><span class="p">(</span>
            <span class="n">rebinned_observed_counts</span><span class="p">,</span>
            <span class="n">rebinned_background_counts</span>
            <span class="o">+</span> <span class="n">rebinned_model_counts</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_scale_factor</span><span class="p">,</span>
            <span class="c1"># min([self._total_scale_factor, 1.0])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_total_scale_factor</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Divide the various cases</span>

        <span class="c1"># TODO check this: shoudn&#39;t it be obseved-background/model (for the old way) and</span>
        <span class="c1"># observed/(model+background) (for the new way). Errors also wrong observed+background error</span>
        <span class="k">if</span> <span class="n">ratio_residuals</span><span class="p">:</span>
            <span class="n">residuals</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">rebinned_observed_counts</span> <span class="o">-</span> <span class="n">rebinned_model_counts</span><span class="p">)</span>
                <span class="o">/</span> <span class="n">rebinned_model_counts</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">residual_errors</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">rebinned_observed_count_errors</span> <span class="o">/</span> <span class="n">rebinned_model_counts</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">residual_errors</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observation_noise_model</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>

                    <span class="c1"># We use the Li-Ma formula to get the significance (sigma)</span>

                    <span class="n">residuals</span> <span class="o">=</span> <span class="n">significance_calc</span><span class="o">.</span><span class="n">li_and_ma</span><span class="p">()</span>

                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;ideal&quot;</span><span class="p">:</span>

                    <span class="n">residuals</span> <span class="o">=</span> <span class="n">significance_calc</span><span class="o">.</span><span class="n">known_background</span><span class="p">()</span>

                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>

                    <span class="n">residuals</span> <span class="o">=</span> <span class="n">significance_calc</span><span class="o">.</span><span class="n">li_and_ma_equivalent_for_gaussian_background</span><span class="p">(</span>
                        <span class="n">rebinned_background_errors</span>
                    <span class="p">)</span>

                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                    <span class="n">residuals</span> <span class="o">=</span> <span class="n">significance_calc</span><span class="o">.</span><span class="n">known_background</span><span class="p">()</span>

                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;modeled&quot;</span><span class="p">:</span>

                    <span class="n">residuals</span> <span class="o">=</span> <span class="n">significance_calc</span><span class="o">.</span><span class="n">known_background</span><span class="p">()</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;This is a bug!&quot;</span><span class="p">)</span>

                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;This is a bug&quot;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">residuals</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">rebinned_observed_counts</span> <span class="o">-</span> <span class="n">rebinned_model_counts</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="n">rebinned_observed_count_errors</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_noise_model</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>

                    <span class="n">residuals</span> <span class="o">=</span> <span class="n">significance_calc</span><span class="o">.</span><span class="n">gaussian_background</span><span class="p">(</span>
                        <span class="n">rebinned_observed_count_errors</span><span class="p">,</span>
                        <span class="n">rebinned_background_errors</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Not yet implemeted!&quot;</span><span class="p">)</span>

                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not yet implemented&quot;</span><span class="p">)</span>

        <span class="c1"># construct a dict with all the new quantities</span>
        <span class="c1"># so that we can extract them for plotting</span>

        <span class="n">rebinned_quantities</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="c1"># Rebined</span>
            <span class="c1"># observed</span>
            <span class="n">new_observed_rate</span><span class="o">=</span><span class="n">new_observed_rate</span><span class="p">,</span>
            <span class="n">new_observed_rate_err</span><span class="o">=</span><span class="n">new_observed_rate_err</span><span class="p">,</span>
            <span class="c1"># background</span>
            <span class="n">new_background_rate</span><span class="o">=</span><span class="n">new_background_rate</span><span class="p">,</span>
            <span class="n">new_background_rate_err</span><span class="o">=</span><span class="n">new_background_rate_err</span><span class="p">,</span>
            <span class="c1"># model</span>
            <span class="n">new_model_rate</span><span class="o">=</span><span class="n">new_model_rate</span><span class="p">,</span>
            <span class="c1"># New echans</span>
            <span class="n">new_chan_width</span><span class="o">=</span><span class="n">new_chan_width</span><span class="p">,</span>
            <span class="n">new_energy_min</span><span class="o">=</span><span class="n">new_energy_min</span><span class="p">,</span>
            <span class="n">new_energy_max</span><span class="o">=</span><span class="n">new_energy_max</span><span class="p">,</span>
            <span class="n">mean_energy</span><span class="o">=</span><span class="n">mean_energy</span><span class="p">,</span>
            <span class="c1"># Residuals</span>
            <span class="n">residuals</span><span class="o">=</span><span class="n">residuals</span><span class="p">,</span>
            <span class="n">residual_errors</span><span class="o">=</span><span class="n">residual_errors</span><span class="p">,</span>
            <span class="n">delta_energy</span><span class="o">=</span><span class="n">delta_energy</span><span class="p">,</span>
            <span class="c1"># Unbinned model rate</span>
            <span class="n">expected_model_rate</span><span class="o">=</span><span class="n">expected_model_rate</span><span class="p">,</span>
            <span class="c1"># Unbinned echans</span>
            <span class="n">energy_min</span><span class="o">=</span><span class="n">energy_min</span><span class="p">,</span>
            <span class="n">energy_max</span><span class="o">=</span><span class="n">energy_max</span><span class="p">,</span>
            <span class="n">chan_width</span><span class="o">=</span><span class="n">chan_width</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">rebinned_quantities</span>

<div class="viewcode-block" id="SpectrumLike.display_model"><a class="viewcode-back" href="../../../notebooks/api/threeML.plugins.html#threeML.plugins.SpectrumLike.SpectrumLike.display_model">[docs]</a>    <span class="k">def</span> <span class="nf">display_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span>
        <span class="n">model_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span>
        <span class="n">background_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span>
        <span class="n">step</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_residuals</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">ratio_residuals</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">min_rate</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-99</span><span class="p">,</span>
        <span class="n">model_label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">data_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">background_label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">background_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">source_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_background</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResidualPlot</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the current model with or without the data and the residuals. Multiple models can be plotted by supplying</span>
<span class="sd">        a previous axis to &#39;model_subplot&#39;.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        fig = data.display_model()</span>

<span class="sd">        fig2 = data2.display_model(model_subplot=fig.axes)</span>


<span class="sd">        :param data_color: the color of the data</span>
<span class="sd">        :param model_color: the color of the model</span>
<span class="sd">        :param step: (bool) create a step count histogram or interpolate the model</span>
<span class="sd">        :param show_data: (bool) show_the data with the model</span>
<span class="sd">        :param show_residuals: (bool) shoe the residuals</span>
<span class="sd">        :param ratio_residuals: (bool) use model ratio instead of residuals</span>
<span class="sd">        :param show_legend: (bool) show legend</span>
<span class="sd">        :param min_rate: the minimum rate per bin</span>
<span class="sd">        :param model_label: (optional) the label to use for the model default is plugin name</span>
<span class="sd">        :param model_subplot: (optional) axis or list of axes to plot to</span>
<span class="sd">        :param model_kwargs: plotting kwargs affecting the plotting of the model</span>
<span class="sd">        :param data_kwargs:  plotting kwargs affecting the plotting of the data and residuls</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set up the default plotting</span>

        <span class="n">_default_model_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">model_color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">_default_background_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">color</span><span class="o">=</span><span class="n">background_color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;--&quot;</span>
        <span class="p">)</span>

        <span class="n">_sub_menu</span> <span class="o">=</span> <span class="n">threeML_config</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">residual_plot</span>

        <span class="n">_default_data_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">color</span><span class="o">=</span><span class="n">data_color</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">fmt</span><span class="o">=</span><span class="n">_sub_menu</span><span class="o">.</span><span class="n">marker</span><span class="p">,</span>
            <span class="n">markersize</span><span class="o">=</span><span class="n">_sub_menu</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
            <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">elinewidth</span><span class="o">=</span><span class="n">_sub_menu</span><span class="o">.</span><span class="n">linewidth</span><span class="p">,</span>
            <span class="n">capsize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># overwrite if these are in the confif</span>

        <span class="n">_kwargs_menu</span><span class="p">:</span> <span class="n">BinnedSpectrumPlot</span> <span class="o">=</span> <span class="n">threeML_config</span><span class="o">.</span><span class="n">plugins</span><span class="o">.</span><span class="n">ogip</span><span class="o">.</span><span class="n">fit_plot</span>

        <span class="k">if</span> <span class="n">_kwargs_menu</span><span class="o">.</span><span class="n">model_mpl_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_kwargs_menu</span><span class="o">.</span><span class="n">model_mpl_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="n">_default_model_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">if</span> <span class="n">_kwargs_menu</span><span class="o">.</span><span class="n">data_mpl_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_kwargs_menu</span><span class="o">.</span><span class="n">data_mpl_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="n">_default_data_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">if</span> <span class="n">_kwargs_menu</span><span class="o">.</span><span class="n">background_mpl_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_kwargs_menu</span><span class="o">.</span><span class="n">background_mpl_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="n">_default_background_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">if</span> <span class="n">model_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">model_kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>

                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;model_kwargs must be a dict&quot;</span><span class="p">)</span>

                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">model_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>

                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_default_model_kwargs</span><span class="p">:</span>

                    <span class="n">_default_model_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="n">_default_model_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">if</span> <span class="n">data_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">data_kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>

                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;data_kwargs must be a dict&quot;</span><span class="p">)</span>

                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>

                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_default_data_kwargs</span><span class="p">:</span>

                    <span class="n">_default_data_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="n">_default_data_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">if</span> <span class="n">background_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">background_kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>

                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;background_kwargs must be a dict&quot;</span><span class="p">)</span>

                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">background_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>

                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_default_background_kwargs</span><span class="p">:</span>

                    <span class="n">_default_background_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="n">_default_background_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="c1"># since we define some defualts, lets not overwrite</span>
        <span class="c1"># the users</span>

        <span class="n">_duplicates</span> <span class="o">=</span> <span class="p">((</span><span class="s2">&quot;ls&quot;</span><span class="p">,</span> <span class="s2">&quot;linestyle&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;lw&quot;</span><span class="p">,</span> <span class="s2">&quot;linewidth&quot;</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">_duplicates</span><span class="p">:</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">_default_model_kwargs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">_default_model_kwargs</span>
            <span class="p">):</span>

                <span class="n">_default_model_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">_default_data_kwargs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">_default_data_kwargs</span>
            <span class="p">):</span>

                <span class="n">_default_data_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">_default_background_kwargs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">_default_background_kwargs</span>
            <span class="p">):</span>

                <span class="n">_default_background_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">model_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_label</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> Model&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

        <span class="n">residual_plot</span> <span class="o">=</span> <span class="n">ResidualPlot</span><span class="p">(</span>
            <span class="n">show_residuals</span><span class="o">=</span><span class="n">show_residuals</span><span class="p">,</span>
            <span class="n">ratio_residuals</span><span class="o">=</span><span class="n">ratio_residuals</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># compute the values for the plotting</span>

        <span class="n">rebinned_quantities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_counts_arrays</span><span class="p">(</span>
            <span class="n">min_rate</span><span class="p">,</span> <span class="n">ratio_residuals</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">source_only</span><span class="p">:</span>
            <span class="n">y_label</span> <span class="o">=</span> <span class="s2">&quot;Net rate</span><span class="se">\n</span><span class="s2">(counts s$^{-1}$ keV$^{-1}$)&quot;</span>
            <span class="n">weighted_data</span> <span class="o">=</span> <span class="n">old_div</span><span class="p">(</span>
                <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_observed_rate&quot;</span><span class="p">]</span>
                <span class="o">-</span> <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_background_rate&quot;</span><span class="p">],</span>
                <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_chan_width&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">weighted_error</span> <span class="o">=</span> <span class="n">old_div</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_observed_rate_err&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
                    <span class="o">+</span> <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_background_rate_err&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="p">),</span>
                <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_chan_width&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_label</span> <span class="o">=</span> <span class="s2">&quot;Observed rate</span><span class="se">\n</span><span class="s2">(counts s$^{-1}$ keV$^{-1}$)&quot;</span>
            <span class="n">weighted_data</span> <span class="o">=</span> <span class="n">old_div</span><span class="p">(</span>
                <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_observed_rate&quot;</span><span class="p">],</span>
                <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_chan_width&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">weighted_error</span> <span class="o">=</span> <span class="n">old_div</span><span class="p">(</span>
                <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_observed_rate_err&quot;</span><span class="p">],</span>
                <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_chan_width&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="c1"># weighted_data = old_div(</span>
        <span class="c1">#    rebinned_quantities[&quot;new_rate&quot;], rebinned_quantities[&quot;new_chan_width&quot;]</span>
        <span class="c1"># )</span>
        <span class="c1"># weighted_error = old_div(</span>
        <span class="c1">#    rebinned_quantities[&quot;new_err&quot;], rebinned_quantities[&quot;new_chan_width&quot;]</span>
        <span class="c1"># )</span>

        <span class="n">residual_plot</span><span class="o">.</span><span class="n">add_data</span><span class="p">(</span>
            <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;mean_energy&quot;</span><span class="p">],</span>
            <span class="n">weighted_data</span><span class="p">,</span>
            <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;residuals&quot;</span><span class="p">],</span>
            <span class="n">residual_yerr</span><span class="o">=</span><span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;residual_errors&quot;</span><span class="p">],</span>
            <span class="n">yerr</span><span class="o">=</span><span class="n">weighted_error</span><span class="p">,</span>
            <span class="n">xerr</span><span class="o">=</span><span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;delta_energy&quot;</span><span class="p">],</span>
            <span class="n">label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
            <span class="n">show_data</span><span class="o">=</span><span class="n">show_data</span><span class="p">,</span>
            <span class="o">**</span><span class="n">_default_data_kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">show_background</span><span class="p">:</span>
            <span class="n">residual_plot</span><span class="o">.</span><span class="n">add_model_step</span><span class="p">(</span>
                <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_energy_min&quot;</span><span class="p">],</span>
                <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_energy_max&quot;</span><span class="p">],</span>
                <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_chan_width&quot;</span><span class="p">],</span>
                <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_background_rate&quot;</span><span class="p">],</span>
                <span class="n">label</span><span class="o">=</span><span class="n">background_label</span><span class="p">,</span>
                <span class="o">**</span><span class="n">_default_background_kwargs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># a step historgram</span>
        <span class="k">if</span> <span class="n">step</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">source_only</span><span class="p">:</span>
                <span class="c1"># only source</span>
                <span class="n">eff_model</span> <span class="o">=</span> <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_model_rate&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">eff_model</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_model_rate&quot;</span><span class="p">]</span>
                    <span class="o">+</span> <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_background_rate&quot;</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="n">residual_plot</span><span class="o">.</span><span class="n">add_model_step</span><span class="p">(</span>
                <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_energy_min&quot;</span><span class="p">],</span>
                <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_energy_max&quot;</span><span class="p">],</span>
                <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;new_chan_width&quot;</span><span class="p">],</span>
                <span class="n">eff_model</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="n">model_label</span><span class="p">,</span>
                <span class="o">**</span><span class="n">_default_model_kwargs</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># residual_plot.add_model_step(</span>
            <span class="c1">#    rebinned_quantities[&quot;new_energy_min&quot;],</span>
            <span class="c1">#    rebinned_quantities[&quot;new_energy_max&quot;],</span>
            <span class="c1">#    rebinned_quantities[&quot;new_chan_width&quot;],</span>
            <span class="c1">#    rebinned_quantities[&quot;new_model_rate&quot;],</span>
            <span class="c1">#    label=model_label,</span>
            <span class="c1">#    **_default_model_kwargs</span>
            <span class="c1"># )</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># We always plot the model un-rebinned here</span>

            <span class="c1"># Mask the array so we don&#39;t plot the model where data have been excluded</span>
            <span class="c1"># y = expected_model_rate / chan_width</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span>
                <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span>
                <span class="n">old_div</span><span class="p">(</span>
                    <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;expected_model_rate&quot;</span><span class="p">],</span>
                    <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;chan_width&quot;</span><span class="p">],</span>
                <span class="p">),</span>
            <span class="p">)</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;energy_min&quot;</span><span class="p">],</span>
                    <span class="n">rebinned_quantities</span><span class="p">[</span><span class="s2">&quot;energy_max&quot;</span><span class="p">],</span>
                <span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">residual_plot</span><span class="o">.</span><span class="n">add_model</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">model_label</span><span class="p">,</span> <span class="o">**</span><span class="n">_default_model_kwargs</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">residual_plot</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span>
            <span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;Energy</span><span class="se">\n</span><span class="s2">(keV)&quot;</span><span class="p">,</span>
            <span class="n">ylabel</span><span class="o">=</span><span class="n">y_label</span><span class="p">,</span>
            <span class="n">xscale</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">,</span>
            <span class="n">yscale</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">,</span>
            <span class="n">show_legend</span><span class="o">=</span><span class="n">show_legend</span><span class="p">,</span>
        <span class="p">)</span></div></div>


<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_trapz</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>


<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_simps</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">diff_fluxes_edges</span><span class="p">,</span> <span class="n">diff_fluxes_mid</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">e2</span> <span class="o">-</span> <span class="n">e1</span><span class="p">)</span>
        <span class="o">/</span> <span class="mf">6.0</span>
        <span class="o">*</span> <span class="p">(</span><span class="n">diff_fluxes_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">diff_fluxes_mid</span> <span class="o">+</span> <span class="n">diff_fluxes_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="p">)</span>


<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_rsum</span><span class="p">(</span><span class="n">model_mid_points</span><span class="p">,</span> <span class="n">de</span><span class="p">):</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">model_mid_points</span><span class="p">,</span> <span class="n">de</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright (2024), the ThreeML developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>